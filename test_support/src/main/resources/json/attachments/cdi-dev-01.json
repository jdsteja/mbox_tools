{
    "author" : "Pete Muir <pmuir@redhat.com>",
    "to" : [ "cdi-dev <cdi-dev@lists.jboss.org>" ],
    "subject_original" : "[cdi-dev] Fwd: JSR-346 Public Review Draft",
    "subject" : "JSR-346 Public Review Draft",
    "date" : "2012-10-26T17:32:33.000Z",
    "message_id_original" : "<C763827E-21C3-4471-BCCC-089F2F5A70FC@redhat.com>",
    "message_id" : "<C763827E-21C3-4471-BCCC-089F2F5A70FC@redhat.com>",
    "references" : [ "<BA0252D3-19B1-40E8-85D0-A72F0C3B5225@redhat.com>" ],
    "message_snippet" : "FYI, I submitted the PRD. I'll push the api to maven central when the JCP confirm the PRD is posted. Begin forwarded message",
    "first_text_message" : "FYI, I submitted the PRD.\n\nI'll push the api to maven central when the JCP confirm the PRD is posted.\n\n\nBegin forwarded message:\n\n&gt; From: Pete Muir &lt;pmuir@redhat.com&gt;\n&gt; Subject: JSR-346 Public Review Draft \n&gt; Date: 26 October 2012 18:31:09 GMT+01:00\n&gt; To: spec-submit@jcp.org\n&gt; \n",
    "first_text_message_without_quotes" : "FYI, I submitted the PRD. I'll push the api to maven central when the JCP confirm the PRD is posted. Begin forwarded message:",
    "text_messages" : [ "&gt;\r\n&gt;\r\n&gt; 1) Please see attached\r\n&gt; 2) 30 days\r\n&gt; 3)\r\n&gt;\r\n&gt; A. Does the specification include software codes\r\n&gt; in the following format:\r\n&gt; Binary : No\r\n&gt; Source (compilable) : No\r\n&gt; Javadocs : Yes\r\n&gt; B. Do the codes or the spec call on, contain, use\r\n&gt; or demonstrate encryption technology? No\r\n&gt;\r\n&gt; 4. Licensing is unchanged\r\n&gt; 5. 12 February 2013\r\n&gt; 6. Version: 1.1, Release Date: 15 March 2013, Spec Lead: Red Hat, Inc. 1801 Varsity Drive, Raleigh, North Carolina 27606. United States.\r\n&gt; 7.\r\n&gt;\r\n&gt; \t• The public can read the names of the people on the Expert Group (ie, not just JCP Members)\r\n&gt;\r\n&gt; http://jcp.org/en/jsr/detail?id46\r\n&gt;\r\n&gt; \t• The Expert Group business is regularly reported on a publicly readable alias.\r\n&gt;\r\n&gt; http://lists.jboss.org/pipermail/cdi-dev/\r\n&gt;\r\n&gt; \t• The schedule for the JSR is publicly available, it's current, and I update it regularly.\r\n&gt;\r\n&gt; https://github.com/jboss/cdi/wiki\r\n&gt;\r\n&gt; \t• The public can read/write to a wiki for my JSR.\r\n&gt;\r\n&gt; https://github.com/jboss/cdi/wiki\r\n&gt;\r\n&gt; \t• I have a discussion board for my JSR and I regularly read and respond to posts on that board.\r\n&gt;\r\n&gt; http://lists.jboss.org/pipermail/cdi-dev/\r\n&gt;\r\n&gt;\r\n&gt; \t• There is an issue-tracker for my JSR that the public can read.\r\n&gt;\r\n&gt; http://issues.jboss.org/browse/CDI\r\n&gt;\r\n&gt; \t• I have spoken at conferences and events about my JSR recently.\r\n&gt;\r\n&gt; Yes, e.g JavaOne\r\n&gt;\r\n&gt; \t• I am using open-source processes for the development of the RI and/or TCK.\r\n&gt;\r\n&gt; Yes. https://github.com/weld & https://github.com/jboss/cdi-tck\r\n&gt;\r\n&gt; \t• The Community tab for my JSR has links to and information about all public communication mechanisms and sites for the development of my JSR.\r\n&gt;\r\n&gt; Yes\r\n\r\n" ],
    "text_messages_cnt" : 1,
    "html_messages_cnt" : 0,
    "message_attachments" : [ {
        "content_type" : "application/pdf",
        "filename" : "cdi-spec.pdf",
        "content" : "Contexts and Dependency Injection for the Java EE platform CDI 1.1 Expert Group Specification lead Pete Muir, Red Hat Middleware, LLC Version CDI 1.1 Public Review Draft 26 October 2012 Table of Contents Evaluation license ............................................................................................................................. vii Foreword .......................................................................................................................................... ix 1. Major changes ........................................................................................................................ ix 1.1. 1.1 Early Draft Review .................................................................................................. ix 1.2. 1.1 Public Review Draft ................................................................................................ ix 2. Open issues ............................................................................................................................ x 2.1. Bean visibility .............................................................................................................. x 2.2. @ApplicationScoped beans shared between all EAR modules ................................................ x 2.3. Startup event ................................................................................................................ x 2.4. @WithAnnotations ........................................................................................................ x 2.5. Allowing arrays as qualifier members ............................................................................... x 2.6. Restricting what CDI scans ............................................................................................. x 2.7. Observer resolution ...................................................................................................... xi 1. Architecture .................................................................................................................................. 1 1.1. Contracts ............................................................................................................................. 1 1.2. Relationship to other specifications ........................................................................................... 2 1.2.1. Relationship to the Java EE platform specification ............................................................ 2 1.2.2. Relationship to EJB ..................................................................................................... 2 1.2.3. Relationship to managed beans ...................................................................................... 2 1.2.4. Relationship to Dependency Injection for Java ................................................................. 3 1.2.5. Relationship to Java Interceptors .................................................................................... 3 1.2.6. Relationship to JSF ..................................................................................................... 3 1.2.7. Relationship to Bean Validation .................................................................................... 3 1.3. Introductory examples ............................................................................................................ 3 1.3.1. JSF example .............................................................................................................. 3 1.3.2. EJB example .............................................................................................................. 5 1.3.3. Java EE component environment example ....................................................................... 6 1.3.4. Event example ........................................................................................................... 6 1.3.5. Injection point metadata example ................................................................................... 7 1.3.6. Interceptor example ..................................................................................................... 8 1.3.7. Decorator example ...................................................................................................... 8 2. Concepts ......................................................................................................................................10 2.1. Functionality provided by the container to the bean .....................................................................10 2.2. Bean types ..........................................................................................................................11 2.2.1. Legal bean types ........................................................................................................11 2.2.2. Restricting the bean types of a bean ...............................................................................11 2.2.3. Typecasting between bean types ...................................................................................12 2.3. Qualifiers ............................................................................................................................12 2.3.1. Built-in qualifier types ................................................................................................13 2.3.2. Defining new qualifier types ........................................................................................13 2.3.3. Declaring the qualifiers of a bean ..................................................................................14 2.3.4. Specifying qualifiers of an injected field .........................................................................14 2.3.5. Specifying qualifiers of a method or constructor parameter ................................................14 2.4. Scopes ...............................................................................................................................15 2.4.1. Built-in scope types ....................................................................................................15 2.4.2. Defining new scope types ............................................................................................15 2.4.3. Declaring the bean scope .............................................................................................16 2.4.4. Default scope ............................................................................................................16 2.5. Bean names .........................................................................................................................16 2.5.1. Declaring the bean name .............................................................................................17 2.5.2. Default bean names ....................................................................................................17 2.5.3. Beans with no name ...................................................................................................17 2.6. Alternatives .........................................................................................................................17 2.6.1. Declaring an alternative ..............................................................................................17 2.7. Stereotypes .........................................................................................................................18 2.7.1. Defining new stereotypes ............................................................................................18 2.7.1.1. Declaring the default scope for a stereotype ..........................................................18 CDI CDI 1.1 Public Review Draft ii 2.7.1.2. Specifying interceptor bindings for a stereotype ....................................................18 2.7.1.3. Declaring a @Named stereotype ........................................................................19 2.7.1.4. Declaring an @Alternative stereotype .................................................................19 2.7.1.5. Stereotypes with additional stereotypes ................................................................19 2.7.2. Declaring the stereotypes for a bean ..............................................................................19 2.7.3. Built-in stereotypes ....................................................................................................20 2.8. Problems detected automatically by the container .......................................................................20 2.9. Priority ordering ...................................................................................................................20 3. Programming model ......................................................................................................................22 3.1. Managed beans ....................................................................................................................22 3.1.1. Which Java classes are managed beans? .........................................................................22 3.1.2. Bean types of a managed bean ......................................................................................22 3.1.3. Declaring a managed bean ...........................................................................................23 3.1.4. Specializing a managed bean ........................................................................................23 3.1.5. Default bean name for a managed bean ..........................................................................23 3.2. Session beans ......................................................................................................................23 3.2.1. EJB remove methods of session beans ...........................................................................24 3.2.2. Bean types of a session bean ........................................................................................24 3.2.3. Declaring a session bean .............................................................................................24 3.2.4. Specializing a session bean ..........................................................................................25 3.2.5. Default bean name for a session bean .............................................................................25 3.3. Producer methods .................................................................................................................25 3.3.1. Bean types of a producer method ..................................................................................26 3.3.2. Declaring a producer method .......................................................................................26 3.3.3. Specializing a producer method ....................................................................................26 3.3.4. Default bean name for a producer method .......................................................................27 3.4. Producer fields .....................................................................................................................27 3.4.1. Bean types of a producer field ......................................................................................27 3.4.2. Declaring a producer field ...........................................................................................28 3.4.3. Default bean name for a producer field ...........................................................................28 3.5. Disposer methods .................................................................................................................28 3.5.1. Disposed parameter of a disposer method .......................................................................28 3.5.2. Declaring a disposer method ........................................................................................29 3.5.3. Disposer method resolution .........................................................................................29 3.6. Resources ...........................................................................................................................30 3.6.1. Declaring a resource ...................................................................................................30 3.6.2. Bean types of a resource ..............................................................................................31 3.7. Additional built-in beans ........................................................................................................31 3.8. Bean constructors .................................................................................................................31 3.8.1. Declaring a bean constructor ........................................................................................31 3.9. Injected fields ......................................................................................................................32 3.9.1. Declaring an injected field ...........................................................................................32 3.10. Initializer methods ..............................................................................................................32 3.10.1. Declaring an initializer method ...................................................................................32 3.11. The default qualifier at injection points ...................................................................................33 3.12. Vetoing types .....................................................................................................................34 3.13. The qualifier @Named at injection points ................................................................................34 3.14. @New qualified beans .........................................................................................................34 3.15. Unproxyable bean types .......................................................................................................35 4. Inheritance and specialization .........................................................................................................36 4.1. Inheritance of type-level metadata ...........................................................................................36 4.2. Inheritance of member-level metadata ......................................................................................37 4.3. Specialization ......................................................................................................................37 4.3.1. Direct and indirect specialization ..................................................................................38 5. Dependency injection, lookup and EL ..............................................................................................40 5.1. Modularity ..........................................................................................................................40 5.1.1. Declaring selected alternatives for a bean archive .............................................................40 5.1.2. Enabled and disabled beans .........................................................................................42 5.1.3. Inconsistent specialization ...........................................................................................42 5.1.4. Inter-module injection ................................................................................................42 5.2. Typesafe resolution ..............................................................................................................43 5.2.1. Performing typesafe resolution .....................................................................................43 Contexts and Dependency Injection for the Java EE platform CDI CDI 1.1 Public Review Draft iii 5.2.2. Unsatisfied and ambiguous dependencies .......................................................................43 5.2.3. Legal injection point types ...........................................................................................44 5.2.4. Assignability of raw and parameterized types ..................................................................44 5.2.5. Primitive types and null values .....................................................................................44 5.2.6. Qualifier annotations with members ..............................................................................44 5.2.7. Multiple qualifiers .....................................................................................................45 5.3. EL name resolution ...............................................................................................................45 5.3.1. Ambiguous EL names .................................................................................................45 5.4. Client proxies ......................................................................................................................46 5.4.1. Client proxy invocation ...............................................................................................46 5.5. Dependency injection ............................................................................................................47 5.5.1. Injection using the bean constructor ...............................................................................47 5.5.2. Injection of fields and initializer methods .......................................................................47 5.5.3. Destruction of dependent objects ..................................................................................47 5.5.4. Invocation of producer or disposer methods ....................................................................48 5.5.5. Access to producer field values ....................................................................................48 5.5.6. Invocation of observer methods ....................................................................................48 5.5.7. Injection point metadata ..............................................................................................48 5.5.8. Bean metadata ...........................................................................................................50 5.6. Programmatic lookup ............................................................................................................51 5.6.1. The Instance interface .................................................................................................51 5.6.2. The built-in Instance ...................................................................................................53 5.6.3. Using AnnotationLiteral and TypeLiteral .......................................................................53 6. Scopes and contexts .......................................................................................................................54 6.1. The Contextual interface ........................................................................................................54 6.1.1. The CreationalContext interface ...................................................................................54 6.2. The Context interface ............................................................................................................55 6.3. Normal scopes and pseudo-scopes ...........................................................................................56 6.4. Dependent pseudo-scope .......................................................................................................56 6.4.1. Dependent objects ......................................................................................................57 6.4.2. Destruction of objects with scope @Dependent ...............................................................57 6.4.3. Dependent pseudo-scope and Unified EL .......................................................................57 6.5. Contextual instances and contextual references ..........................................................................57 6.5.1. The active context object for a scope .............................................................................58 6.5.2. Contextual instance of a bean .......................................................................................58 6.5.3. Contextual reference for a bean ....................................................................................58 6.5.4. Contextual reference validity .......................................................................................59 6.5.5. Injectable references ...................................................................................................59 6.5.6. Injectable reference validity .........................................................................................59 6.6. Passivation and passivating scopes ..........................................................................................60 6.6.1. Passivation capable beans ............................................................................................60 6.6.2. Passivation capable dependencies .................................................................................60 6.6.3. Passivating scopes .....................................................................................................60 6.6.4. Validation of passivation capable beans and dependencies .................................................61 6.7. Context management for built-in scopes ...................................................................................61 6.7.1. Request context lifecycle .............................................................................................61 6.7.2. Session context lifecycle .............................................................................................62 6.7.3. Application context lifecycle ........................................................................................62 6.7.4. Conversation context lifecycle ......................................................................................63 6.7.5. The Conversation interface ..........................................................................................64 7. Lifecycle of contextual instances ......................................................................................................66 7.1. Restriction upon bean instantiation ..........................................................................................66 7.2. Container invocations and interception .....................................................................................67 7.3. Lifecycle of contextual instances .............................................................................................67 7.3.1. Lifecycle of managed beans .........................................................................................67 7.3.2. Lifecycle of stateful session beans .................................................................................68 7.3.3. Lifecycle of stateless session and singleton beans .............................................................68 7.3.4. Lifecycle of producer methods .....................................................................................68 7.3.5. Lifecycle of producer fields .........................................................................................68 7.3.6. Lifecycle of resources .................................................................................................69 8. Decorators ....................................................................................................................................70 8.1. Decorator beans ...................................................................................................................70 Contexts and Dependency Injection for the Java EE platform CDI CDI 1.1 Public Review Draft iv 8.1.1. Declaring a decorator .................................................................................................70 8.1.2. Decorator delegate injection points ................................................................................70 8.1.3. Decorated types of a decorator .....................................................................................71 8.2. Decorator enablement and ordering ..........................................................................................71 8.3. Decorator resolution .............................................................................................................72 8.3.1. Assignability of raw and parameterized types for delegate injection points ............................73 8.4. Decorator invocation .............................................................................................................73 9. Interceptor bindings ......................................................................................................................74 9.1. Interceptor binding types .......................................................................................................74 9.1.1. Interceptor binding types with additional interceptor bindings ............................................74 9.1.2. Interceptor bindings for stereotypes ...............................................................................74 9.2. Declaring the interceptor bindings of an interceptor ....................................................................74 9.3. Binding an interceptor to a bean ..............................................................................................75 9.4. Interceptor enablement and ordering ........................................................................................75 9.5. Interceptor resolution ............................................................................................................77 9.5.1. Interceptors with multiple bindings ...............................................................................77 9.5.2. Interceptor binding types with members .........................................................................78 10. Events ........................................................................................................................................79 10.1. Event types and qualifier types ..............................................................................................79 10.2. Observer resolution .............................................................................................................79 10.2.1. Assignability of type variables, raw and parameterized types ............................................79 10.2.2. Event qualifier types with members .............................................................................80 10.2.3. Multiple event qualifiers ............................................................................................80 10.3. Firing events ......................................................................................................................81 10.3.1. The Event interface ..................................................................................................81 10.3.2. The built-in Event ....................................................................................................82 10.4. Observer methods ...............................................................................................................82 10.4.1. Event parameter of an observer method ........................................................................82 10.4.2. Declaring an observer method ....................................................................................82 10.4.3. Conditional observer methods ....................................................................................83 10.4.4. Transactional observer methods ..................................................................................83 10.5. Observer notification ...........................................................................................................84 10.5.1. Observer method invocation context ............................................................................84 11. Portable extensions ......................................................................................................................86 11.1. The Bean interface ..............................................................................................................86 11.1.1. The Decorator interface .............................................................................................86 11.1.2. The Interceptor interface ............................................................................................87 11.1.3. The ObserverMethod interface ....................................................................................87 11.2. The Producer and InjectionTarget interfaces ............................................................................87 11.3. The BeanManager object .....................................................................................................88 11.3.1. Obtaining a reference to the CDI container ....................................................................89 11.3.2. Obtaining a contextual reference for a bean ...................................................................89 11.3.3. Obtaining an injectable reference ................................................................................89 11.3.4. Obtaining a CreationalContext ....................................................................................90 11.3.5. Obtaining a Bean by type ...........................................................................................90 11.3.6. Obtaining a Bean by name .........................................................................................90 11.3.7. Obtaining a passivation capable bean by identifier ..........................................................90 11.3.8. Resolving an ambiguous dependency ...........................................................................90 11.3.9. Validating an injection point ......................................................................................91 11.3.10. Firing an event .......................................................................................................91 11.3.11. Observer method resolution ......................................................................................91 11.3.12. Decorator resolution ................................................................................................91 11.3.13. Interceptor resolution ..............................................................................................92 11.3.14. Determining if an annotation is a qualifier type, scope type, stereotype or interceptor binding type .................................................................................................................................92 11.3.15. Determining the hash code and equivalence of qualifiers and interceptor bindings ...............92 11.3.16. Obtaining the active Context for a scope .....................................................................92 11.3.17. Obtaining the ELResolver ........................................................................................93 11.3.18. Wrapping a Unified EL ExpressionFactory ..................................................................93 11.3.19. Obtaining an AnnotatedType for a class ......................................................................93 11.3.20. Obtaining an InjectionTarget for a class ......................................................................93 11.3.21. Obtaining a Producer for a field or method ..................................................................93 Contexts and Dependency Injection for the Java EE platform CDI CDI 1.1 Public Review Draft v 11.3.22. Obtaining an InjectionPoint ......................................................................................93 11.3.23. Obtaining a BeanAttributes ......................................................................................93 11.3.24. Obtaining a Bean ....................................................................................................94 11.3.25. Obtaining the instance of an Extension .......................................................................94 11.4. Alternative metadata sources ................................................................................................94 11.5. Container lifecycle events ....................................................................................................96 11.5.1. BeforeBeanDiscovery event .......................................................................................97 11.5.2. AfterBeanDiscovery event .........................................................................................97 11.5.3. AfterDeploymentValidation event ...............................................................................98 11.5.4. BeforeShutdown event ..............................................................................................98 11.5.5. ProcessModule event ................................................................................................98 11.5.6. ProcessAnnotatedType event ......................................................................................99 11.5.7. ProcessInjectionPoint event ...................................................................................... 100 11.5.8. ProcessInjectionTarget event .................................................................................... 100 11.5.9. ProcessProducer event ............................................................................................ 101 11.5.10. ProcessBeanAttributes event ................................................................................... 102 11.5.11. ProcessBean event ................................................................................................ 102 11.5.12. ProcessObserverMethod event ................................................................................ 103 12. Packaging and deployment ......................................................................................................... 105 12.1. Bean archives .................................................................................................................. 105 12.2. Application initialization lifecycle ....................................................................................... 106 12.3. Application shutdown lifecycle ........................................................................................... 106 12.4. Bean discovery ................................................................................................................. 106 12.5. Integration with Unified EL ................................................................................................ 107 Contexts and Dependency Injection for the Java EE platform CDI CDI 1.1 Public Review Draft vi Evaluation license Copyright 2009 Red Hat Middleware LLC. All rights reserved. NOTICE The Specification is protected by copyright and the information described therein may be protected by one or more U.S. patents, foreign patents, or pending applications. Except as provided under the following license, no part of the Specifica- tion may be reproduced in any form by any means without the prior written authorization of Red Hat Middleware LLC and its licensors, if any. Any use of the Specification and the information described therein will be governed by the terms and conditions of this Agreement. Subject to the terms and conditions of this license, including your compliance with Paragraphs 1 and 2 below, Red Hat Middleware LLC hereby grants you a fully-paid, non-exclusive, non-transferable, limited license (without the right to sub- license) under Red Hat Middleware LLC's intellectual property rights to: 1. Review the Specification for the purposes of evaluation. This includes: (i) developing implementations of the Specifica- tion for your internal, non-commercial use; (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification. 2. Distribute implementations of the Specification to third parties for their testing and evaluation use, provided that any such implementation: (i) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; (ii) is clearly and prominently marked with the word \"UNTESTED\" or \"EARLY ACCESS\" or \"INCOMPATIBLE\" or \"UNSTABLE\" or \"BETA\" in any list of available builds and in proximity to every link initiating its download, where the list or link is under Licensee's control; and (iii) includes the following notice: \"This is an implementation of an early-draft specification developed under the Java Community Process (JCP). The code is not compatible with any specification of the JCP.\" The grant set forth above concerning your distribution of implementations of the Specification is contingent upon your agreement to terminate development and distribution of your implementation of early draft upon final completion of the Specification. If you fail to do so, the foregoing grant shall be considered null and void. No provision of this Agreement shall be understood to restrict your ability to make and distribute to third parties applica- tions written to the Specification. Other than this limited license, you acquire no right, para or interest in or to the Specification or any other Red Hat Mid- dleware LLC intellectual property, and the Specification may only be used in accordance with the license terms set forth herein. This license will expire on the earlier of: (a) two (2) years from the date of Release listed above; (b) the date on which the final version of the Specification is publicly released; or (c) the date on which the Java Specification Request (JSR) to which the Specification corresponds is withdrawn. In addition, this license will terminate immediately without notice from Red Hat Middleware LLC if you fail to comply with any provision of this license. Upon termination, you must cease use of or destroy the Specification. \"Licensor Name Space\" means the public class or interface declarations whose names begin with \"java\", \"javax\", \"com.redhat\" or their equivalents in any subsequent naming convention adopted through the Java Community Process, or any recognized successors or replacements thereof. TRADEMARKS No right, para, or interest in or to any trademarks, service marks, or trade names of Red Hat Middleware LLC or Red Hat's licensors is granted hereunder. Java and Java-related logos, marks and names are trademarks or registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries. CDI CDI 1.1 Public Review Draft vii DISCLAIMER OF WARRANTIES THE SPECIFICATION IS PROVIDED \"AS IS\" AND IS EXPERIMENTAL AND MAY CONTAIN DEFECTS OR DE- FICIENCIES WHICH CANNOT OR WILL NOT BE CORRECTED BY RED HAT MIDDLEWARE LLC. RED HAT MIDDLEWARE LLC MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, IN- CLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR THAT ANY PRACTICE OR IMPLEMENTATION OF SUCH CONTENTS WILL NOT IN- FRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR OTHER RIGHTS. This document does not represent any commitment to release or implement any portion of the Specification in any product. THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION THEREIN; THESE CHANGES WILL BE IN- CORPORATED INTO NEW VERSIONS OF THE SPECIFICATION, IF ANY. RED HAT MIDDLEWARE LLC MAY MAKE IMPROVEMENTS AND/OR CHANGES TO THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY TIME. Any use of such changes in the Specification will be governed by the then- current license for the applicable version of the Specification. LIMITATION OF LIABILITY TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL RED HAT MIDDLEWARE LLC OR ITS LI- CENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING, MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF RED HAT MIDDLEWARE LLC AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAM- AGES. You will hold Red Hat Middleware LLC (and its licensors) harmless from any claims based on your use of the Specifica- tion for any purposes other than the limited right of evaluation as described above, and from any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this li- cense. RESTRICTED RIGHTS LEGEND If this Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions). REPORT You may wish to report any ambiguities, inconsistencies or inaccuracies you may find in connection with your evaluation of the Specification (\"Feedback\"). To the extent that you provide Red Hat Middleware LLC with any Feedback, you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Red Hat Middleware LLC a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof. GENERAL TERMS Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Con- vention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply. The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other coun- tries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee. This Agreement is the parties' entire agreement relating to its subject matter. It supersedes all prior or contemporaneous or- al or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party. Evaluation license CDI CDI 1.1 Public Review Draft viii Foreword Contexts and Dependency Injection 1.1 (JSR-346) is an update to Contexts and Dependency Injection 1.0 (JSR-299). A full changelog can be found in the issue tracker release notes for CDI 1.1 [https://issues.jboss.org/secure/ReleaseNote.jspa?projectId=12311062&version=12315956]. 1. Major changes 1.1. 1.1 Early Draft Review • @Disposes methods for producer fields • The CDI class, which provides programmatic access to CDI facilities from outside a managed bean • Pass the qualifiers an event was fired with to the ObserverMethod • Ability to veto beans declaratively using @Veto and @Requires • Ability to access the BeanManager from the ServletContext • Conversations in Servlet requests • Application lifecycle events in Java EE • Injection of Bean metadata into bean instances • Programmatic access to a container provided Producer, InjectionTarget, AnnotatedType • Ability to override attributes of a Bean via BeanAttributes • Ability to process modules via ProcessModule • Ability to wrap the InjectionPoint • Ability to obtain Extension instances from BeanManager • Injection of the ServletContext • Access to beans.xml in ProcessModule • Injection into enums 1.2. 1.1 Public Review Draft • ProcessAnnotatedType fired for annotations • Moved all Bean Validation integration to Bean Validation Specification as Bean Validation 1.1 PRD • Clarify what beans are available during container lifecycle events • Honor WEB-INF/classes/META-INF/beans.xml to activate WEB-INF/classes a bean archive • Global ordering and enablement of interceptors and decorators • Global selection of alternatives • @New deprecated • JMS MessageListener removed as not available in Java EE • Support for unmanaged instances via Instance.destroy() CDI CDI 1.1 Public Review Draft ix • Clarify interceptors and decorators must be implemented using proxying • Allow multiple annotated types per Java class • Allow Extensions to specify the annotations that they are interested in 2. Open issues The expert group still has a number of topics under discussion, as of the Public Review Draft. Some of these are minor, alignment issues, or naming issues, however some of these directly affect core CDI concepts, and these are listed here. 2.1. Bean visibility The CDI 1.0 specification clearly states that only beans whose bean class is accessible (using standard classloader visibil- ity rules) can be injected into another bean. For example, if you have a bean A in WAR, assuming standard Java EE class- loader structure, it wouldn't be available for injection in bean B, in an EJB modiule. This generally makes sense, as the type is not visible either. CDI also offers two options to replace bean implementations transparently, without explicitly selecting that implementa- tion (either by type or using a qualifier) - alternatives and specialization. In this case, it is less clear that the bean class of the specializing bean, or the bean class selected alternative, must be visible. The CDI EG is still debating this issue, including whether to offer a backwards incompatible mode here. 2.2. @ApplicationScoped beans shared between all EAR modules CDI implementations have not consistently shared @ApplicationScoped beans accross all modules of an EAR. This issue heavily relates to Bean visibility. The CDI 1.1 specification will clearly state how @ApplicationScoped are shared. 2.3. Startup event A commonly requested feature is for the application to be able to do some work once the application has started but before it starts servicing requests originating remotely. Currently CDI 1.1 defines a @Initialized(ApplicationScoped.class) which is called when the application context starts, but we are investigating whether this can be extended to provide a more general startup event. If we define such an event, we need to allow custom contexts to activate themselves whilst it is executing, however this is likely beyond the scope of CDI 1.1 and will likely be addressed in CDI 2.0. 2.4. @WithAnnotations CDI 1.1 adds @WithAnnotations which allows an extension observing ProcessAnnotatedType to filter which types it sees. We would like to provide such functionality for all container lifecycle event observers, but there are some interesting things to consider, including whether it would be better to filter on qualifiers for later events. CDI 1.1 may or may not add such support, and we are looking for feedback on this. 2.5. Allowing arrays as qualifier members CDI 1.0 requires array valued members of qualifiers to be annotated with @Nonbinding, excluding them from the resolu- tion process. The JDK defines that annotation equality for array valued members should use Arrays.equals(), which re- quires two identical arrays (equal values, in the same order) in order to return true. We feel that to make array valued members of qualifiers useful, we need to offer a pluggable strategy for checking equal- ity of arrays, as often it would be desirable to consider two arrays with the same values, in any order, as equal. We intend to add this for CDI 1.1. 2.6. Restricting what CDI scans CDI 1.0 will scan all classes in a jar with beans.xml. We plan to add a syntax to beans.xml that will the application de- Foreword CDI CDI 1.1 Public Review Draft x veloper to exclude classes using a variety of filtering options (e.g. by package). Weld offers such a syntax, and will be used as a starting point for CDI http://docs.jboss.org/weld/reference/1.1.5.Final/en-US/html/configure.html#d0e5769. 2.7. Observer resolution CDI 1.0 requires the type used for observer resolution to be based on the runtime type of the event object. Unfortunately, the JDK erases generic type information about objects that we need to allow firing of many events with parameterized types. CDI 1.0 also completely ignores the generic type of the injected event object, which does typically contain the needed type information. We therefore intend to change the event observer resolution rules to allow the generic type of the event object to be taken into account if the runtime event object does not contain sufficient information. Note that this may seem like a backwards incompatible change, however CDI 1.0 is essentially unimplementable today - examples in the spec do not work as described. Foreword CDI CDI 1.1 Public Review Draft xi Chapter 1. Architecture This specification defines a powerful set of complementary services that help improve the structure of application code. • A well-defined lifecycle for stateful objects bound to lifecycle contexts, where the set of contexts is extensible • A sophisticated, typesafe dependency injection mechanism, including the ability to select dependencies at either devel- opment or deployment time, without verbose configuration • Support for Java EE modularity and the Java EE component architecture—the modular structure of a Java EE applica- tion is taken into account when resolving dependencies between Java EE components • Integration with the Unified Expression Language (EL), allowing any contextual object to be used directly within a JSF or JSP page • The ability to decorate injected objects • The ability to associate interceptors to objects via typesafe interceptor bindings • An event notification model • A web conversation context in addition to the three standard web contexts defined by the Java Servlets specification • An SPI allowing portable extensions to integrate cleanly with the container The services defined by this specification allow objects to be bound to lifecycle contexts, to be injected, to be associated with interceptors and decorators, and to interact in a loosely coupled fashion by firing and observing events. Various kinds of objects are injectable, including EJB 3 session beans, managed beans and Java EE resources. We refer to these objects in general terms as beans and to instances of beans that belong to contexts as contextual instances. Contextual instances may be injected into other objects by the dependency injection service. To take advantage of these facilities, the developer provides additional bean-level metadata in the form of Java annotations and application-level metadata in the form of an XML descriptor. The use of these services significantly simplifies the task of creating Java EE applications by integrating the Java EE web tier with Java EE enterprise services. In particular, EJB components may be used as JSF managed beans, thus integrating the programming models of EJB and JSF. It's even possible to integrate with third-party frameworks. A portable extension may provide objects to be injected or ob- tain contextual instances using the dependency injection service. The framework may even raise and observe events using the event notification service. An application that takes advantage of these services may be designed to execute in either the Java EE environment or the Java SE environment. If the application uses Java EE services such as transaction management and persistence in the Java SE environment, the services are usually restricted to, at most, the subset defined for embedded usage by the EJB specific- ation. 1.1. Contracts This specification defines the responsibilities of: • the application developer who uses these services, and • the vendor who implements the functionality defined by this specification and provides a runtime environment in which the application executes. This runtime environment is called the container. For example, the container might be a Java EE container or an embed- dable EJB container. Chapter 2, Concepts, Chapter 3, Programming model, Chapter 4, Inheritance and specialization, Chapter 9, Interceptor bindings, Section 8.1, “Decorator beans” and Section 10.4, “Observer methods” define the programming model for Java EE components that take advantage of the services defined by this specification, the responsibilities of the component de- CDI CDI 1.1 Public Review Draft 1 veloper, and the annotations used by the component developer to specify metadata. Chapter 5, Dependency injection, lookup and EL, Chapter 6, Scopes and contexts, Chapter 7, Lifecycle of contextual in- stances, Chapter 8, Decorators, Chapter 10, Events and Section 9.5, “Interceptor resolution” define the semantics and be- havior of the services, the responsibilities of the container implementation and the APIs used by the application to interact directly with the container. Chapter 12, Packaging and deployment defines how Java EE applications that use the services defined by this specifica- tion must be packaged into bean archives, and the responsibilities of the container implementation at application initializa- tion time. Chapter 11, Portable extensions, Section 6.1, “The Contextual interface” and Section 6.2, “The Context interface” define an SPI that allows portable extensions to integrate with the container. 1.2. Relationship to other specifications An application developer creates container-managed components such as JavaBeans, EJBs or servlets and then provides additional metadata that declares additional behavior defined by this specification. These components may take advantage of the services defined by this specification, together with the enterprise and presentational aspects defined by other Java EE platform technologies. In addition, this specification defines an SPI that allows alternative, non-platform technologies to integrate with the con- tainer and the Java EE environment, for example, alternative web presentation technologies. 1.2.1. Relationship to the Java EE platform specification In the Java EE 6 environment, all component classes supporting injection, as defined by the Java EE 6 platform specifica- tion, may inject beans via the dependency injection service. The Java EE platform specification defines a facility for injecting resources that exist in the Java EE component environ- ment. Resources are identified by string-based names. This specification bolsters that functionality, adding the ability to in- ject an open-ended set of object types, including, but not limited to, component environment resources, based upon typesafe qualifiers. 1.2.2. Relationship to EJB EJB defines a programming model for application components that access transactional resources in a multi-user environ- ment. EJB allows concerns such as role-based security, transaction demarcation, concurrency and scalability to be spe- cified declaratively using annotations and XML deployment descriptors and enforced by the EJB container at runtime. EJB components may be stateful, but are not by nature contextual. References to stateful component instances must be ex- plicitly passed between clients and stateful instances must be explicitly destroyed by the application. This specification enhances the EJB component model with contextual lifecycle management. Any session bean instance obtained via the dependency injection service is a contextual instance. It is bound to a lifecycle context and is available to other objects that execute in that context. The container automatically creates the instance when it is needed by a client. When the context ends, the container automatically destroys the instance. Message-driven and entity beans are by nature non-contextual objects and may not be injected into other objects. The container performs dependency injection on all session and message-driven bean instances, even those which are not contextual instances. 1.2.3. Relationship to managed beans The Managed Beans specification defines the basic programming model for application components managed by the Java EE container. As defined by this specification, most Java classes, including all JavaBeans, are managed beans. This specification defines contextual lifecycle management and dependency injection as generic services applicable to all Architecture CDI CDI 1.1 Public Review Draft 2 managed beans. Any managed bean instance obtained via the dependency injection service is a contextual instance. It is bound to a life- cycle context and is available to other objects that execute in that context. The container automatically creates the instance when it is needed by a client. When the context ends, the container automatically destroys the instance. The container performs dependency injection on all managed bean instances, even those which are not contextual in- stances. 1.2.4. Relationship to Dependency Injection for Java The Dependency Injection for Java specification defines a set of annotations for the declaring injected fields, methods and constructors of a bean. The dependency injection service makes use of these annotations. 1.2.5. Relationship to Java Interceptors The Java Interceptors specification defines the basic programming model and semantics for interceptors. This specification enhances that model by providing the ability to associate interceptors with beans using typesafe interceptor bindings. 1.2.6. Relationship to JSF JavaServer Faces is a web-tier presentation framework that provides a component model for graphical user interface com- ponents and an event-driven interaction model that binds user interface components to objects accessible via Unified EL. This specification allows any bean to be assigned a name. Thus, a JSF application may take advantage of the sophisticated context and dependency injection model defined by this specification. 1.2.7. Relationship to Bean Validation Bean Validation provides a unified way of declaring and defining constraints on an object model, defines a runtime engine to validate objects and provides method validation. The Bean Validation specification defines beans for Bean Validation managed objects including Validator and Validat- orFactory. A number of Bean Validation managed instances, including ConstraintValidators can take advantage of de- pendency injection. Bean Validation also provides support for method parameter validation on any bean. 1.3. Introductory examples The following examples demonstrate the use of lifecycle contexts and dependency injection. 1.3.1. JSF example The following JSF page defines a login prompt for a web application: <f:view> <h:form> <h:panelGrid columns=\"2\" rendered=\"#{!login.loggedIn}\"> <h:outputLabel for=\"username\">Username:</h:outputLabel> <h:inputText id=\"username\" value=\"#{credentials.username}\"/> <h:outputLabel for=\"password\">Password:</h:outputLabel> <h:inputText id=\"password\" value=\"#{credentials.password}\"/> </h:panelGrid> <h:commandButton value=\"Login\" action=\"#{login.login}\" rendered=\"#{!login.loggedIn}\"/> <h:commandButton value=\"Logout\" action=\"#{login.logout}\" rendered=\"#{login.loggedIn}\"/> </h:form> </f:view> The Unified EL expressions in this page refer to beans named credentials and login. The Credentials bean has a lifecycle that is bound to the JSF request: @Model public class Credentials { Architecture CDI CDI 1.1 Public Review Draft 3 private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } The @Model annotation defined in Section 2.7.3, “Built-in stereotypes” is a stereotype that identifies the Credentials bean as a model object in an MVC architecture. The Login bean has a lifecycle that is bound to the HTTP session: @SessionScoped @Model public class Login implements Serializable { @Inject Credentials credentials; @Inject @Users EntityManager userDatabase; private CriteriaQuery<User> query; private Parameter<String> usernameParam; private Parameter<String> passwordParam; private User user; @Inject void initQuery(@Users EntityManagerFactory emf) { CriteriaBuilder cb = emf.getCriteriaBuilder(); usernameParam = cb.parameter(String.class); passwordParam = cb.parameter(String.class); query = cb.createQuery(User.class); Root<User> u = query.from(User.class); query.select(u); query.where( cb.equal(u.get(User_.username), usernameParam), cb.equal(u.get(User_.password), passwordParam) ); } public void login() { List<User> results = userDatabase.createQuery(query) .setParameter(usernameParam, credentials.getUsername()) .setParameter(passwordParam, credentials.getPassword()) .getResultList(); if ( !results.isEmpty() ) { user = results.get(0); } } public void logout() { user = null; } public boolean isLoggedIn() { return user!=null; } @Produces @LoggedIn User getCurrentUser() { if (user==null) { throw new NotLoggedInException(); } else { return user; } } } The @SessionScoped annotation defined in Section 2.4.1, “Built-in scope types” is a scope type that specifies the lifecycle of instances of Login. Managed beans with this scope must be serializable. The @Inject annotation defined by the Dependency Injection for Java specification identifies an injected field which is initialized by the container when the bean is instantiated, or an initializer method which is called by the container after the bean is instantiated, with injected parameters. Architecture CDI CDI 1.1 Public Review Draft 4 The @Users annotation is a qualifier type defined by the application: @Qualifier @Retention(RUNTIME) @Target({METHOD, FIELD, PARAMETER, TYPE}) public @interface Users {} The @LoggedIn annotation is another qualifier type defined by the application: @Qualifier @Retention(RUNTIME) @Target({METHOD, FIELD, PARAMETER, TYPE}) public @interface LoggedIn {} The @Produces annotation defined in Section 3.3.2, “Declaring a producer method” identifies the method getCur- rentUser() as a producer method, which will be called whenever another bean in the system needs the currently logged-in user, for example, whenever the user attribute of the DocumentEditor class is injected by the container: @Model public class DocumentEditor { @Inject Document document; @Inject @LoggedIn User currentUser; @Inject @Documents EntityManager docDatabase; public void save() { document.setCreatedBy(currentUser); em.persist(document); } } The @Documents annotation is another application-defined qualifier type. The use of distinct qualifier types enables the container to distinguish which JPA persistence unit is required. When the login form is submitted, JSF assigns the entered username and password to an instance of the Credentials bean that is automatically instantiated by the container. Next, JSF calls the login() method of an instance of Login that is auto- matically instantiated by the container. This instance continues to exist for and be available to other requests in the same HTTP session, and provides the User object representing the current user to any other bean that requires it (for example, DocumentEditor). If the producer method is called before the login() method initializes the user object, it throws a Not- LoggedInException. 1.3.2. EJB example Alternatively, we could write our Login bean to take advantage of the functionality defined by EJB: @Stateful @SessionScoped @Model public class Login { @Inject Credentials credentials; @Inject @Users EntityManager userDatabase; ... private User user; @Inject void initQuery(@Users EntityManagerFactory emf) { ... } @TransactionAttribute(REQUIRES_NEW) @RolesAllowed(\"guest\") public void login() { ... } public void logout() { user = null; } public boolean isLoggedIn() { return user!=null; } Architecture CDI CDI 1.1 Public Review Draft 5 @RolesAllowed(\"user\") @Produces @LoggedIn User getCurrentUser() { ... } } The EJB @Stateful annotation specifies that this bean is an EJB stateful session bean. The EJB @TransactionAttribute and @RolesAllowed annotations declare the EJB transaction demarcation and security attributes of the annotated methods. 1.3.3. Java EE component environment example In the previous examples, we injected container-managed persistence contexts using qualifier types. We need to tell the container what persistence context is being referred to by which qualifier type. We can declare references to persistence contexts and other resources in the Java EE component environment in Java code. public class Databases { @Produces @PersistenceContext(unitName=\"UserData\") @Users EntityManager userDatabaseEntityManager; @Produces @PersistenceUnit(unitName=\"UserData\") @Users EntityManagerFactory userDatabaseEntityManagerFactory; @Produces @PersistenceContext(unitName=\"DocumentData\") @Documents EntityManager docDatabaseEntityManager; } The JPA @PersistenceContext and @PersistenceUnit annotations identify the JPA persistence unit. 1.3.4. Event example Beans may raise events. For example, our Login class could raise events when a user logs in or out. @SessionScoped @Model public class Login implements Serializable { @Inject Credentials credentials; @Inject @Users EntityManager userDatabase; @Inject @LoggedIn Event<User> userLoggedInEvent; @Inject @LoggedOut Event<User> userLoggedOutEvent; ... private User user; @Inject void initQuery(@Users EntityManagerFactory emf) { ... } public void login() { List<User> results = ... ; if ( !results.isEmpty() ) { user = results.get(0); userLoggedInEvent.fire(user); } } public void logout() { userLoggedOutEvent.fire(user); user = null; } public boolean isLoggedIn() { return user!=null; } @Produces @LoggedIn User getCurrentUser() { ... } Architecture CDI CDI 1.1 Public Review Draft 6 } The method fire() of the built-in bean of type Event defined in Section 10.3.1, “The Event interface” allows the applica- tion to fire events. Events consist of an event object—in this case the User—and event qualifiers. Event qualifiers—such as @LoggedIn and @LoggedOut—allow event consumers to specify which events of a certain type they are interested in. Other beans may observe these events and use them to synchronize their internal state, with no coupling to the bean produ- cing the events: @SessionScoped public class Permissions implements Serializable { @Produces private Set<Permission> permissions = new HashSet<Permission>(); @Inject @Users EntityManager userDatabase; Parameter<String> usernameParam; CriteriaQuery<Permission> query; @Inject void initQuery(@Users EntityManagerFactory emf) { CriteriaBuilder cb = emf.getCriteriaBuilder(); usernameParam = cb.parameter(String.class); query = cb.createQuery(Permission.class); Root<Permission> p = query.from(Permission.class); query.select(p); query.where( cb.equal(p.get(Permission_.user).get(User_.username), usernameParam) ); } void onLogin(@Observes @LoggedIn User user) { permissions = new HashSet<Permission>( userDatabase.createQuery(query) .setParameter(usernameParam, user.getUsername()) .getResultList() ); } void onLogout(@Observes @LoggedOut User user { permissions.clear(); } } The @Produces annotation applied to a field identifies the field as a producer field, as defined in Section 3.4, “Producer fields”, a kind of shortcut version of a producer method. This producer field allows the permissions of the current user to be injected to an injection point of type Set<Permission>. The @Observes annotation defined in Section 10.4.2, “Declaring an observer method” identifies the method with the an- notated parameter as an observer method that is called by the container whenever an event matching the type and qualifiers of the annotated parameter is fired. 1.3.5. Injection point metadata example It is possible to implement generic beans that introspect the injection point to which they belong. This makes it possible to implement injection for Loggers, for example. class Loggers { @Produces Logger getLogger(InjectionPoint injectionPoint) { return Logger.getLogger( injectionPoint.getMember().getDeclaringClass().getSimpleName() ); } } The InjectionPoint interface defined in Section 5.5.7, “Injection point metadata”, provides metadata about the injection point to the object being injected into it. Then this class will have a Logger named \"Permissions\" injected: @SessionScoped public class Permissions implements Serializable { @Inject Logger log; Architecture CDI CDI 1.1 Public Review Draft 7 ... } 1.3.6. Interceptor example Interceptors allow common, cross-cutting concerns to be applied to beans via custom annotations. Interceptor types may be individually enabled or disabled at deployment time. The AuthorizationInterceptor class defines a custom authorization check: @Secure @Interceptor public class AuthorizationInterceptor { @Inject @LoggedIn User user; @Inject Logger log; @AroundInvoke public Object authorize(InvocationContext ic) throws Exception { try { if ( !user.isBanned() ) { log.fine(\"Authorized\"); return ic.proceed(); } else { log.fine(\"Not authorized\"); throw new NotAuthorizedException(); } } catch (NotAuthenticatedException nae) { log.fine(\"Not authenticated\"); throw nae; } } } The @Interceptor annotation, defined in Section 9.2, “Declaring the interceptor bindings of an interceptor”, identifies the AuthorizationInterceptor class as an interceptor. The @Secure annotation is a custom interceptor binding type, as defined in Section 9.1, “Interceptor binding types”. @Inherited @InterceptorBinding @Target({TYPE, METHOD}) @Retention(RUNTIME) public @interface Secure {} The @Secure annotation is used to apply the interceptor to a bean: @Model public class DocumentEditor { @Inject Document document; @Inject @LoggedIn User user; @Inject @Documents EntityManager em; @Secure public void save() { document.setCreatedBy(currentUser); em.persist(document); } } When the save() method is invoked, the authorize() method of the interceptor will be called. The invocation will pro- ceed to the DocumentEditor class only if the authorization check is successful. 1.3.7. Decorator example Decorators are similar to interceptors, but apply only to beans of a particular Java interface. Like interceptors, decorators may be easily enabled or disabled at deployment time. Unlike interceptors, decorators are aware of the semantics of the in- tercepted method. Architecture CDI CDI 1.1 Public Review Draft 8 For example, the DataAccess interface might be implemented by many beans: public interface DataAccess<T, V> { public V getId(T object); public T load(V id); public void save(T object); public void delete(T object); public Class<T> getDataType(); } The DataAccessAuthorizationDecorator class defines the authorization checks: @Decorator public abstract class DataAccessAuthorizationDecorator<T, V> implements DataAccess<T, V> { @Inject @Delegate DataAccess<T, V> delegate; @Inject Logger log; @Inject Set<Permission> permissions; public void save(T object) { authorize(SecureAction.SAVE, object); delegate.save(object); } public void delete(T object) { authorize(SecureAction.DELETE, object); delegate.delete(object); } private void authorize(SecureAction action, T object) { V id = delegate.getId(object); Class<T> type = delegate.getDataType(); if ( permissions.contains( new Permission(action, type, id) ) ) { log.fine(\"Authorized for \" + action); } else { log.fine(\"Not authorized for \" + action); throw new NotAuthorizedException(action); } } } The @Decorator annotation defined in Section 8.1.1, “Declaring a decorator” identifies the DataAccessAuthorization- Decorator class as a decorator. The @Delegate annotation defined in Section 8.1.2, “Decorator delegate injection points” identifies the delegate, which the decorator uses to delegate method calls to the container. The decorator applies to any bean that implements DataAccess. The decorator intercepts invocations just like an interceptor. However, unlike an interceptor, the decorator contains func- tionality that is specific to the semantics of the method being called. Decorators may be declared abstract, relieving the developer of the responsibility of implementing all methods of the dec- orated interface. If a decorator does not implement a method of a decorated interface, the decorator will simply not be called when that method is invoked upon the decorated bean. Architecture CDI CDI 1.1 Public Review Draft 9 Chapter 2. Concepts A Java EE component is a bean if the lifecycle of its instances may be managed by the container according to the lifecycle context model defined in Chapter 6, Scopes and contexts. A bean may bear metadata defining its lifecycle and interactions with other components. Speaking more abstractly, a bean is a source of contextual objects which define application state and/or logic. These ob- jects are called contextual instances of the bean. The container creates and destroys these instances and associates them with the appropriate context. Contextual instances of a bean may be injected into other objects (including other bean in- stances) that execute in the same context, and may be used in EL expressions that are evaluated in the same context. A bean comprises the following attributes: • A (nonempty) set of bean types • A (nonempty) set of qualifiers • A scope • Optionally, a bean name • A set of interceptor bindings • A bean implementation Furthermore, a bean may or may not be an alternative. In most cases, a bean developer provides the bean implementation by writing business logic in Java code. The developer then defines the remaining attributes by explicitly annotating the bean class, or by allowing them to be defaulted by the container, as specified in Chapter 3, Programming model. In certain other cases—for example, Java EE component envir- onment resources, defined in Section 3.6, “Resources”—the developer provides only the annotations and the bean imple- mentation is provided by the container. The bean types and qualifiers of a bean determine where its instances will be injected by the container, as defined in Chapter 5, Dependency injection, lookup and EL. The bean developer may also create interceptors and/or decorators or reuse existing interceptors and/or decorators. The in- terceptor bindings of a bean determine which interceptors will be applied at runtime. The bean types and qualifiers of a bean determine which decorators will be applied at runtime. Interceptors are defined by Java interceptors specification, and interceptor bindings are specified in Chapter 9, Interceptor bindings. Decorators are defined in Chapter 8, Decorators. 2.1. Functionality provided by the container to the bean A bean is provided by the container with the following capabilities: • transparent creation and destruction and scoping to a particular context, specified in Chapter 6, Scopes and contexts and Chapter 7, Lifecycle of contextual instances, • scoped resolution by bean type and qualifier annotation type when injected into a Java-based client, as defined by Sec- tion 5.2, “Typesafe resolution”, • scoped resolution by bean name when used in a Unified EL expression, as defined by Section 5.3, “EL name resolu- tion”, • lifecycle callbacks and automatic injection of other bean instances, specified in Chapter 3, Programming model and Chapter 5, Dependency injection, lookup and EL, • method interception, callback interception, and decoration, as defined in Chapter 9, Interceptor bindings and Chapter 8, Decorators, and • event notification, as defined in Chapter 10, Events. CDI CDI 1.1 Public Review Draft 10 2.2. Bean types A bean type defines a client-visible type of the bean. A bean may have multiple bean types. For example, the following bean has four bean types: public class BookShop extends Business implements Shop<Book> { ... } The bean types are BookShop, Business, Shop<Book> and Object. Meanwhile, this session bean has only the local interfaces BookShop and Auditable, along with Object, as bean types, since the bean class is not a client-visible type. @Stateful public class BookShopBean extends Business implements BookShop, Auditable { ... } The rules for determining the (unrestricted) set of bean types for a bean are defined in Section 3.1.2, “Bean types of a man- aged bean”, Section 3.2.2, “Bean types of a session bean”, Section 3.3.1, “Bean types of a producer method”, Sec- tion 3.4.1, “Bean types of a producer field” and Section 3.6.2, “Bean types of a resource”. All beans have the bean type java.lang.Object. The bean types of a bean are used by the rules of typesafe resolution defined in Section 5.2, “Typesafe resolution”. 2.2.1. Legal bean types Almost any Java type may be a bean type of a bean: • A bean type may be an interface, a concrete class or an abstract class, and may be declared final or have final methods. • A bean type may be a parameterized type with actual type parameters and type variables. • A bean type may be an array type. Two array types are considered identical only if the element type is identical. • A bean type may be a primitive type. Primitive types are considered to be identical to their corresponding wrapper types in java.lang. • A bean type may be a raw type. A type variable is not a legal bean type. A parameterized type that contains a wildcard type parameter is not a legal bean type. Note that certain additional restrictions are specified in Section 3.15, “Unproxyable bean types” for beans with a normal scope, as defined in Section 6.3, “Normal scopes and pseudo-scopes”. 2.2.2. Restricting the bean types of a bean The bean types of a bean may be restricted by annotating the bean class or producer method or field with the annotation @javax.enterprise.inject.Typed. @Typed(Shop.class) public class BookShop extends Business implements Shop<Book> { ... } When a @Typed annotation is explicitly specified, only the types whose classes are explicitly listed using the value mem- ber, together with java.lang.Object, are bean types of the bean. Concepts CDI CDI 1.1 Public Review Draft 11 In the example, the bean has a two bean types: Shop<Book> and Object. If a bean class or producer method or field specifies a @Typed annotation, and the value member specifies a class which does not correspond to a type in the unrestricted set of bean types of a bean, the container automatically detects the prob- lem and treats it as a definition error. 2.2.3. Typecasting between bean types A client of a bean may typecast its contextual reference to a bean to any bean type of the bean which is a Java interface. However, the client may not in general typecast its contextual reference to an arbitrary concrete bean type of the bean. For example, if our managed bean was injected to the following field: @Inject Business biz; Then the following typecast is legal: Shop<Book> bookShop = (Shop<Book>) biz; However, the following typecast is not legal and might result in an exception at runtime: BookShop bookShop = (BookShop) biz; 2.3. Qualifiers For a given bean type, there may be multiple beans which implement the type. For example, an application may have two implementations of the interface PaymentProcessor: class SynchronousPaymentProcessor implements PaymentProcessor { ... } class AsynchronousPaymentProcessor implements PaymentProcessor { ... } A client that needs a PaymentProcessor that processes payments synchronously needs some way to distinguish between the two different implementations. One approach would be for the client to explicitly specify the class that implements the PaymentProcessor interface. However, this approach creates a hard dependence between client and implementa- tion—exactly what use of the interface was designed to avoid! A qualifier type represents some client-visible semantic associated with a type that is satisfied by some implementations of the type (and not by others). For example, we could introduce qualifier types representing synchronicity and asynchron- icity. In Java code, qualifier types are represented by annotations. @Synchronous class SynchronousPaymentProcessor implements PaymentProcessor { ... } @Asynchronous class AsynchronousPaymentProcessor implements PaymentProcessor { ... } Finally, qualifier types are applied to injection points to distinguish which implementation is required by the client. For ex- ample, when the container encounters the following injected field, an instance of SynchronousPaymentProcessor will be injected: @Inject @Synchronous PaymentProcessor paymentProcessor; Concepts CDI CDI 1.1 Public Review Draft 12 But in this case, an instance of AsynchronousPaymentProcessor will be injected: @Inject @Asynchronous PaymentProcessor paymentProcessor; The container inspects the qualifier annotations and type of the injected attribute to determine the bean instance to be in- jected, according to the rules of typesafe resolution defined in Section 5.2, “Typesafe resolution”. An injection point may even specify multiple qualifiers. Qualifier types are also used as event selectors by event consumers, as defined in Chapter 10, Events, and to bind decorat- ors to beans, as specified in Chapter 8, Decorators. 2.3.1. Built-in qualifier types Three standard qualifier types are defined in the package javax.enterprise.inject. In addition, the built-in qualifier type @Named is defined by the package javax.inject. Every bean has the built-in qualifier @Any, even if it does not explicitly declare this qualifier, except for the special @New qualified beans defined in Section 3.14, “@New qualified beans”. If a bean does not explicitly declare a qualifier other than @Named, the bean has exactly one additional qualifier, of type @Default. This is called the default qualifier. The following declarations are equivalent: @Default public class Order { ... } public class Order { ... } Both declarations result in a bean with two qualifiers: @Any and @Default. The following declaration results in a bean with three qualifiers: @Any, @Default and @Named(\"ord\"). @Named(\"ord\") public class Order { ... } The default qualifier is also assumed for any injection point that does not explicitly declare a qualifier, as defined in Sec- tion 3.11, “The default qualifier at injection points”. The following declarations, in which the use of the @Inject annota- tion identifies the constructor parameter as an injection point, are equivalent: public class Order { @Inject public Order(@Default OrderProcessor processor) { ... } } public class Order { @Inject public Order(OrderProcessor processor) { ... } } 2.3.2. Defining new qualifier types A qualifier type is a Java annotation defined as @Retention(RUNTIME). Typically a qualifier type is defined as @Target({METHOD, FIELD, PARAMETER, TYPE}). A qualifier type may be declared by specifying the @javax.inject.Qualifier meta-annotation. @Qualifier @Retention(RUNTIME) @Target({METHOD, FIELD, PARAMETER, TYPE}) public @interface Synchronous {} @Qualifier @Retention(RUNTIME) @Target({METHOD, FIELD, PARAMETER, TYPE}) Concepts CDI CDI 1.1 Public Review Draft 13 public @interface Asynchronous {} A qualifier type may define annotation members. @Qualifier @Retention(RUNTIME) @Target({METHOD, FIELD, PARAMETER, TYPE}) public @interface PayBy { PaymentMethod value(); } 2.3.3. Declaring the qualifiers of a bean The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types. @LDAP class LdapAuthenticator implements Authenticator { ... } public class Shop { @Produces @All public List<Product> getAllProducts() { ... } @Produces @WishList public List<Product> getWishList() { ... } } Any bean may declare multiple qualifier types. @Synchronous @Reliable class SynchronousReliablePaymentProcessor implements PaymentProcessor { ... } 2.3.4. Specifying qualifiers of an injected field Qualifier types may be applied to injected fields (see Section 3.9, “Injected fields”) to determine the bean that is injected, according to the rules of typesafe resolution defined in Section 5.2, “Typesafe resolution”. @Inject @LDAP Authenticator authenticator; A bean may only be injected to an injection point if it has all the qualifiers of the injection point. @Inject @Synchronous @Reliable PaymentProcessor paymentProcessor; @Inject @All List<Product> catalog; @Inject @WishList List<Product> wishList; 2.3.5. Specifying qualifiers of a method or constructor parameter Qualifier types may be applied to parameters of producer methods, initializer methods, disposer methods, observer meth- ods or bean constructors (see Chapter 3, Programming model) to determine the bean instance that is passed when the method is called by the container. The container uses the rules of typesafe resolution defined in Section 5.2, “Typesafe res- olution” to determine values for these parameters. For example, when the container encounters the following producer method, an instance of SynchronousPaymentPro- cessor will be passed to the first parameter and an instance of AsynchronousPaymentProcessor will be passed to the second parameter: @Produces Concepts CDI CDI 1.1 Public Review Draft 14 PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor sync, @Asynchronous PaymentProcessor async) { return isSynchronous() ? sync : async; } 2.4. Scopes Java EE components such as servlets, EJBs and JavaBeans do not have a well-defined scope. These components are either: • singletons, such as EJB singleton beans, whose state is shared between all clients, • stateless objects, such as servlets and stateless session beans, which do not contain client-visible state, or • objects that must be explicitly created and destroyed by their client, such as JavaBeans and stateful session beans, whose state is shared by explicit reference passing between clients. Scoped objects, by contrast, exist in a well-defined lifecycle context: • they may be automatically created when needed and then automatically destroyed when the context in which they were created ends, and • their state is automatically shared by clients that execute in the same context. All beans have a scope. The scope of a bean determines the lifecycle of its instances, and which instances of the bean are visible to instances of other beans, as defined in Chapter 6, Scopes and contexts. A scope type is represented by an annota- tion type. For example, an object that represents the current user is represented by a session scoped object: @Produces @SessionScoped User getCurrentUser() { ... } An object that represents an order is represented by a conversation scoped object: @ConversationScoped public class Order { ... } A list that contains the results of a search screen might be represented by a request scoped object: @Produces @RequestScoped @Named(\"orders\") List<Order> getOrderSearchResults() { ... } The set of scope types is extensible. 2.4.1. Built-in scope types There are five standard scope types defined by this specification, all defined in the package javax.enterprise.context. • The @RequestScoped, @ApplicationScoped and @SessionScoped annotations defined in Section 6.7, “Context man- agement for built-in scopes” represent the standard scopes defined by the Java Servlets specification. • The @ConversationScoped annotation represents the conversation scope defined in Section 6.7.4, “Conversation con- text lifecycle”. • Finally, there is a @Dependent pseudo-scope for dependent objects, as defined in Section 6.4, “Dependent pseudo- scope”. If an interceptor or decorator has any scope other than @Dependent, non-portable behavior results. 2.4.2. Defining new scope types A scope type is a Java annotation defined as @Retention(RUNTIME). Typically a scope type is defined as @Target({TYPE, METHOD, FIELD}). All scope types must also specify the @javax.inject.Scope or Concepts CDI CDI 1.1 Public Review Draft 15 @javax.enterprise.context.NormalScope meta-annotation. A scope type must not have any attributes. If a scope type has attributes non-portable behavior results. For example, the following annotation declares a \"business process scope\": @Inherited @NormalScope @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface BusinessProcessScoped {} Custom scopes are normally defined by portable extensions, which must also provide a context object, as defined in Sec- tion 6.2, “The Context interface”, that implements the custom scope. 2.4.3. Declaring the bean scope The scope of a bean is defined by annotating the bean class or producer method or field with a scope type. A bean class or producer method or field may specify at most one scope type annotation. If a bean class or producer meth- od or field specifies multiple scope type annotations, the container automatically detects the problem and treats it as a definition error. public class Shop { @Produces @ApplicationScoped @All public List<Product> getAllProducts() { ... } @Produces @SessionScoped @WishList public List<Product> getWishList() { ..... } } Likewise, a bean with the custom business process scope may be declared by annotating it with the @BusinessProcessScoped annotation: @BusinessProcessScoped public class Order { ... } Alternatively, a scope type may be specified using a stereotype annotation, as defined in Section 2.7.2, “Declaring the ste- reotypes for a bean”. 2.4.4. Default scope When no scope is explicitly declared by annotating the bean class or producer method or field the scope of a bean is de- faulted. The default scope for a bean which does not explicitly declare a scope depends upon its declared stereotypes: • If the bean does not declare any stereotype with a declared default scope, the default scope for the bean is @Dependent. • If all stereotypes declared by the bean that have some declared default scope have the same default scope, then that scope is the default scope for the bean. • If there are two different stereotypes declared by the bean that declare different default scopes, then there is no default scope and the bean must explicitly declare a scope. If it does not explicitly declare a scope, the container automatically detects the problem and treats it as a definition error. If a bean explicitly declares a scope, any default scopes declared by stereotypes are ignored. 2.5. Bean names A bean may have a bean name. A bean with a name may be referred to by its name in Unified EL expressions. A valid bean name is a period-separated list of valid EL identifiers. Concepts CDI CDI 1.1 Public Review Draft 16 The following strings are valid bean names: org.mydomain.myapp.settings orderManager There is no relationship between the bean name of a session bean and the EJB name of the bean. Subject to the restrictions defined in Section 5.3.1, “Ambiguous EL names”, multiple beans may share the same bean name. Bean names allow the direct use of beans in JSP or JSF pages, as defined in Section 12.5, “Integration with Unified EL”. For example, a bean with the name products could be used like this: <h:outputText value=\"#{products.total}\"/> Bean names are used by the rules of EL name resolution defined in Section 5.3, “EL name resolution”. 2.5.1. Declaring the bean name To specify the name of a bean, the qualifier @javax.inject.Named is applied to the bean class or producer method or field. This bean is named currentOrder: @Named(\"currentOrder\") public class Order { ... } 2.5.2. Default bean names In the following circumstances, a default name must be assigned by the container: • A bean class or producer method or field of a bean declares a @Named annotation and no bean name is explicitly spe- cified by the value member. • A bean declares a stereotype that declares an empty @Named annotation, and the bean does not explicitly specify a bean name. If a bean class or producer method or field of a bean declares a @Named annotation and no bean name is explicitly specified the value of the value member is defaulted. The default name for a bean depends upon the kind of the bean. The rules for determining the default name for a bean are defined in Section 3.1.5, “Default bean name for a managed bean”, Section 3.2.5, “Default bean name for a session bean”, Section 3.3.4, “Default bean name for a producer method” and Section 3.4.3, “Default bean name for a producer field”. 2.5.3. Beans with no name If @Named is not declared by the bean, nor by its stereotypes, a bean has no name. If an interceptor or decorator has a name, non-portable behavior results. 2.6. Alternatives An alternative is a bean that must be explicitly declared in the beans.xml file if it should be available for lookup, injection or EL resolution. 2.6.1. Declaring an alternative An alternative may be declared by annotating the bean class or producer method or field with the @Alternative annota- tion. @Alternative public class MockOrder extends Order { ... } Concepts CDI CDI 1.1 Public Review Draft 17 Alternatively, an alternative may be declared by annotating a bean, producer method or producer field with a stereotype that declares an @Alternative annotation. If an interceptor or decorator is an alternative, non-portable behavior results. 2.7. Stereotypes In many systems, use of architectural patterns produces a set of recurring bean roles. A stereotype allows a framework de- veloper to identify such a role and declare some common metadata for beans with that role in a central place. A stereotype encapsulates any combination of: • a default scope, and • a set of interceptor bindings. A stereotype may also specify that: • all beans with the stereotype have defaulted bean names, or that • all beans with the stereotype are alternatives. A bean may declare zero, one or multiple stereotypes. 2.7.1. Defining new stereotypes A bean stereotype is a Java annotation defined as @Retention(RUNTIME). Typically a bean stereotype is defined as @Target({TYPE, METHOD, FIELD}), @Target(TYPE), @Target(METHOD), @Target(FIELD) or @Target({METHOD, FIELD}). A stereotype may be declared by specifying the @javax.enterprise.inject.Stereotype meta-annotation. @Stereotype @Target(TYPE) @Retention(RUNTIME) public @interface Action {} 2.7.1.1. Declaring the default scope for a stereotype The default scope of a stereotype is defined by annotating the stereotype with a scope type. A stereotype may declare at most one scope. If a stereotype declares more than one scope, the container automatically detects the problem and treats it as a definition error. For example, the following stereotype might be used to identify action classes in a web application: @RequestScoped @Stereotype @Target(TYPE) @Retention(RUNTIME) public @interface Action {} Then actions would have scope @RequestScoped unless the scope is explicitly specified by the bean. 2.7.1.2. Specifying interceptor bindings for a stereotype The interceptor bindings of a stereotype are defined by annotating the stereotype with the interceptor binding types. A ste- reotype may declare zero, one or multiple interceptor bindings, as defined in Section 9.1.2, “Interceptor bindings for ste- reotypes”. We may specify interceptor bindings that apply to all actions: @RequestScoped @Secure @Transactional @Stereotype Concepts CDI CDI 1.1 Public Review Draft 18 @Target(TYPE) @Retention(RUNTIME) public @interface Action {} 2.7.1.3. Declaring a @Named stereotype A stereotype may declare an empty @Named annotation, which specifies that every bean with the stereotype has a defaulted name when a name is not explicitly specified by the bean. A @Named qualifier declared by a stereotype is not added to the qualifiers of a bean with the stereotype. If a stereotype declares a non-empty @Named annotation, the container automatically detects the problem and treats it as a definition error. We may specify that all actions have bean names: @RequestScoped @Secure @Transactional @Named @Stereotype @Target(TYPE) @Retention(RUNTIME) public @interface Action {} A stereotype should not declare any qualifier annotation other than @Named. If a stereotype declares any other qualifier an- notation, non-portable behavior results. A stereotype should not be annotated @Typed. If a stereotype is annotated @Typed, non-portable behavior results. 2.7.1.4. Declaring an @Alternative stereotype A stereotype may declare an @Alternative annotation, which specifies that every bean with the stereotype is an alternat- ive. We may specify that all mock objects are alternatives: @Alternative @Stereotype @Target(TYPE) @Retention(RUNTIME) public @interface Mock {} 2.7.1.5. Stereotypes with additional stereotypes A stereotype may declare other stereotypes. @Auditable @Action @Stereotype @Target(TYPE) @Retention(RUNTIME) public @interface AuditableAction {} Stereotype declarations are transitive—a stereotype declared by a second stereotype is inherited by all beans and other ste- reotypes that declare the second stereotype. Stereotypes declared @Target(TYPE) may not be applied to stereotypes declared @Target({TYPE, METHOD, FIELD}), @Target(METHOD), @Target(FIELD) or @Target({METHOD, FIELD}). 2.7.2. Declaring the stereotypes for a bean Stereotype annotations may be applied to a bean class or producer method or field. @Action public class LoginAction { ... } The default scope declared by the stereotype may be overridden by the bean: Concepts CDI CDI 1.1 Public Review Draft 19 @Mock @ApplicationScoped @Action public class MockLoginAction extends LoginAction { ... } Multiple stereotypes may be applied to the same bean: @Dao @Action public class LoginAction { ... } 2.7.3. Built-in stereotypes The built-in stereotype @javax.enterprise.inject.Model is intended for use with beans that define the model layer of an MVC web application architecture such as JSF: @Named @RequestScoped @Stereotype @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface Model {} In addition, the special-purpose @Interceptor and @Decorator stereotypes are defined in Section 9.2, “Declaring the in- terceptor bindings of an interce"
    }, {
        "content_type" : "application/zip",
        "filename" : "cdi-api-1.1-PRD.zip",
        "content" : "META-INF/MANIFEST.MF Manifest-Version: 1.0 Archiver-Version: Plexus Archiver Created-By: Apache Maven Built-By: pmuir Build-Jdk: 1.6.0_37 Implementation-Title: CDI APIs Implementation-URL: http://www.seamframework.org/Weld Implementation-Vendor: JBoss by Red Hat, Inc. Implementation-Version: 20121026-1818 Specification-Title: CDI APIs Specification-Vendor: JBoss by Red Hat, Inc. Specification-Version: 1.1.0.PRD Name: Build-Information Maven-Version: 3.0.4 Build-Time: 20121026-1818 Os-Name: Mac OS X Java-Version: 1.6.0_37 Java-Vendor: Apple Inc. Os-Version: 10.7.4 Os-Arch: x86_64 SCM: r${buildNumber} beans_1_0.xsd Contexts and Dependency Injection (CDI) defines a set of complementary services that help improve the structure of application code. beans.xml is used to enable CDI services for the current bean archive as well as to enable named interceptors, decorators and alternatives for the current bean archive. Bean classes of enabled beans must be deployed in bean archives. A library jar, EJB jar, application client jar or rar archive is a bean archive if it has a file named beans.xml in the META-INF directory. The WEB-INF/classes directory of a war is a bean archive if there is a file named beans.xml in the WEB-INF directory of the war. A directory in the JVM classpath is a bean archive if it has a file named beans.xml in the META-INF directory. By default, a bean archive has no enabled interceptors bound via interceptor bindings. An interceptor must be explicitly enabled by listing its class under the <interceptors> element of the beans.xml file of the bean archive. The order of the interceptor declarations determines the interceptor ordering. Interceptors which occur earlier in the list are called first. If the same class is listed twice under the <interceptors> element, the container automatically detects the problem and treats it as a deployment problem. Each child <class> element must specify the name of an interceptor class. If there is no class with the specified name, or if the class with the specified name is not an interceptor class, the container automatically detects the problem and treats it as a deployment problem. By default, a bean archive has no enabled decorators. A decorator must be explicitly enabled by listing its bean class under the <decorators> element of the beans.xml file of the bean archive. The order of the decorator declarations determines the decorator ordering. Decorators which occur earlier in the list are called first. If the same class is listed twice under the <decorators> element, the container automatically detects the problem and treats it as a deployment problem. Each child <class> element must specify the name of a decorator class. If there is no class with the specified name, or if the class with the specified name is not a decorator class, the container automatically detects the problem and treats it as a deployment problem. An alternative is a bean that must be explicitly declared in the beans.xml file if it should be available for lookup, injection or EL resolution. By default, a bean archive has no selected alternatives. An alternative must be explicitly declared using the <alternatives> element of the beans.xml file of the bean archive. The <alternatives> element contains a list of bean classes and stereotypes. An alternative is selected for the bean archive if either: the alternative is a managed bean or session bean and the bean class of the bean is listed, or the alternative is a producer method, field or resource, and the bean class that declares the method or field is listed, or any @Alternative stereotype of the alternative is listed. Each child <class> element must specify the name of an alternative bean class. If there is no class with the specified name, or if the class with the specified name is not an alternative bean class, the container automatically detects the problem and treats it as a deployment problem. If the same class is listed twice under the <alternatives> element, the container automatically detects the problem and treats it as a deployment problem. Each child <stereotype> element must specify the name of an @Alternative stereotype annotation. If there is no annotation with the specified name, or the annotation is not an @Alternative stereotype, the container automatically detects the problem and treats it as a deployment problem. If the same stereotype is listed twice under the <alternatives> element, the container automatically detects the problem and treats it as a deployment problem. javax/decorator/Decorator.class package javax.decorator; public abstract interface Decorator extends annotation.Annotation { } javax/decorator/Delegate.class package javax.decorator; public abstract interface Delegate extends annotation.Annotation { } javax/enterprise/context/ApplicationScoped.class package javax.enterprise.context; public abstract interface ApplicationScoped extends annotation.Annotation { } javax/enterprise/context/BusyConversationException.class package javax.enterprise.context; public synchronized class BusyConversationException extends ContextException { private static final long serialVersionUID = -3599813072560026919; public void BusyConversationException(); public void BusyConversationException(String); public void BusyConversationException(Throwable); public void BusyConversationException(String, Throwable); } javax/enterprise/context/ContextException.class package javax.enterprise.context; public synchronized class ContextException extends RuntimeException { private static final long serialVersionUID = -3599813072560026919; public void ContextException(); public void ContextException(String); public void ContextException(Throwable); public void ContextException(String, Throwable); } javax/enterprise/context/ContextNotActiveException.class package javax.enterprise.context; public synchronized class ContextNotActiveException extends ContextException { private static final long serialVersionUID = -3599813072560026919; public void ContextNotActiveException(); public void ContextNotActiveException(String); public void ContextNotActiveException(Throwable); public void ContextNotActiveException(String, Throwable); } javax/enterprise/context/Conversation.class package javax.enterprise.context; public abstract interface Conversation { public abstract void begin(); public abstract void begin(String); public abstract void end(); public abstract String getId(); public abstract long getTimeout(); public abstract void setTimeout(long); public abstract boolean isTransient(); } javax/enterprise/context/ConversationScoped.class package javax.enterprise.context; public abstract interface ConversationScoped extends annotation.Annotation { } javax/enterprise/context/Dependent.class package javax.enterprise.context; public abstract interface Dependent extends annotation.Annotation { } javax/enterprise/context/Destroyed.class package javax.enterprise.context; public abstract interface Destroyed extends annotation.Annotation { public abstract Class value(); } javax/enterprise/context/Initialized.class package javax.enterprise.context; public abstract interface Initialized extends annotation.Annotation { public abstract Class value(); } javax/enterprise/context/NonexistentConversationException.class package javax.enterprise.context; public synchronized class NonexistentConversationException extends ContextException { private static final long serialVersionUID = -3599813072560026919; public void NonexistentConversationException(); public void NonexistentConversationException(String); public void NonexistentConversationException(Throwable); public void NonexistentConversationException(String, Throwable); } javax/enterprise/context/NormalScope.class package javax.enterprise.context; public abstract interface NormalScope extends annotation.Annotation { public abstract boolean passivating(); } javax/enterprise/context/RequestScoped.class package javax.enterprise.context; public abstract interface RequestScoped extends annotation.Annotation { } javax/enterprise/context/SessionScoped.class package javax.enterprise.context; public abstract interface SessionScoped extends annotation.Annotation { } javax/enterprise/context/spi/AlterableContext.class package javax.enterprise.context.spi; public abstract interface AlterableContext extends Context { public abstract void destroy(Contextual); } javax/enterprise/context/spi/Context.class package javax.enterprise.context.spi; public abstract interface Context { public abstract Class getScope(); public abstract Object get(Contextual, CreationalContext); public abstract Object get(Contextual); public abstract boolean isActive(); } javax/enterprise/context/spi/Contextual.class package javax.enterprise.context.spi; public abstract interface Contextual { public abstract Object create(CreationalContext); public abstract void destroy(Object, CreationalContext); } javax/enterprise/context/spi/CreationalContext.class package javax.enterprise.context.spi; public abstract interface CreationalContext { public abstract void push(Object); public abstract void release(); } javax/enterprise/event/Event.class package javax.enterprise.event; public abstract interface Event { public abstract void fire(Object); public abstract transient Event select(annotation.Annotation[]); public abstract transient Event select(Class, annotation.Annotation[]); public abstract transient Event select(javax.enterprise.util.TypeLiteral, annotation.Annotation[]); } javax/enterprise/event/ObserverException.class package javax.enterprise.event; public synchronized class ObserverException extends RuntimeException { private static final long serialVersionUID = -801836224808304381; public void ObserverException(); public void ObserverException(String); public void ObserverException(Throwable); public void ObserverException(String, Throwable); } javax/enterprise/event/Observes.class package javax.enterprise.event; public abstract interface Observes extends annotation.Annotation { public abstract Reception notifyObserver(); public abstract TransactionPhase during(); } javax/enterprise/event/Reception.class package javax.enterprise.event; public final synchronized enum Reception { public static final Reception IF_EXISTS; public static final Reception ALWAYS; public static Reception[] values(); public static Reception valueOf(String); private void Reception(String, int); static void <clinit>(); } javax/enterprise/event/TransactionPhase.class package javax.enterprise.event; public final synchronized enum TransactionPhase { public static final TransactionPhase IN_PROGRESS; public static final TransactionPhase BEFORE_COMPLETION; public static final TransactionPhase AFTER_COMPLETION; public static final TransactionPhase AFTER_FAILURE; public static final TransactionPhase AFTER_SUCCESS; public static TransactionPhase[] values(); public static TransactionPhase valueOf(String); private void TransactionPhase(String, int); static void <clinit>(); } javax/enterprise/inject/Alternative.class package javax.enterprise.inject; public abstract interface Alternative extends annotation.Annotation { } javax/enterprise/inject/AmbiguousResolutionException.class package javax.enterprise.inject; public synchronized class AmbiguousResolutionException extends ResolutionException { private static final long serialVersionUID = -2132733164534544788; public void AmbiguousResolutionException(); public void AmbiguousResolutionException(String, Throwable); public void AmbiguousResolutionException(String); public void AmbiguousResolutionException(Throwable); } javax/enterprise/inject/Any.class package javax.enterprise.inject; public abstract interface Any extends annotation.Annotation { } javax/enterprise/inject/CreationException.class package javax.enterprise.inject; public synchronized class CreationException extends InjectionException { private static final long serialVersionUID = 1002854668862145298; public void CreationException(); public void CreationException(String); public void CreationException(Throwable); public void CreationException(String, Throwable); } javax/enterprise/inject/Decorated.class package javax.enterprise.inject; public abstract interface Decorated extends annotation.Annotation { } javax/enterprise/inject/Default.class package javax.enterprise.inject; public abstract interface Default extends annotation.Annotation { } javax/enterprise/inject/Disposes.class package javax.enterprise.inject; public abstract interface Disposes extends annotation.Annotation { } javax/enterprise/inject/IllegalProductException.class package javax.enterprise.inject; public synchronized class IllegalProductException extends InjectionException { private static final long serialVersionUID = -6280627846071966243; public void IllegalProductException(); public void IllegalProductException(String, Throwable); public void IllegalProductException(String); public void IllegalProductException(Throwable); } javax/enterprise/inject/InjectionException.class package javax.enterprise.inject; public synchronized class InjectionException extends RuntimeException { private static final long serialVersionUID = -2132733164534544788; public void InjectionException(); public void InjectionException(String, Throwable); public void InjectionException(String); public void InjectionException(Throwable); } javax/enterprise/inject/Instance.class package javax.enterprise.inject; public abstract interface Instance extends Iterable, javax.inject.Provider { public abstract transient Instance select(annotation.Annotation[]); public abstract transient Instance select(Class, annotation.Annotation[]); public abstract transient Instance select(javax.enterprise.util.TypeLiteral, annotation.Annotation[]); public abstract boolean isUnsatisfied(); public abstract boolean isAmbiguous(); public abstract void destroy(Object); } javax/enterprise/inject/Intercepted.class package javax.enterprise.inject; public abstract interface Intercepted extends annotation.Annotation { } javax/enterprise/inject/Model.class package javax.enterprise.inject; public abstract interface Model extends annotation.Annotation { } javax/enterprise/inject/New.class package javax.enterprise.inject; public abstract interface New extends annotation.Annotation { public abstract Class value(); } javax/enterprise/inject/Produces.class package javax.enterprise.inject; public abstract interface Produces extends annotation.Annotation { } javax/enterprise/inject/ResolutionException.class package javax.enterprise.inject; public synchronized class ResolutionException extends InjectionException { private static final long serialVersionUID = -6280627846071966243; public void ResolutionException(); public void ResolutionException(String, Throwable); public void ResolutionException(String); public void ResolutionException(Throwable); } javax/enterprise/inject/Specializes.class package javax.enterprise.inject; public abstract interface Specializes extends annotation.Annotation { } javax/enterprise/inject/spi/AfterBeanDiscovery.class package javax.enterprise.inject.spi; public abstract interface AfterBeanDiscovery { public abstract void addDefinitionError(Throwable); public abstract void addBean(Bean); public abstract void addObserverMethod(ObserverMethod); public abstract void addContext(javax.enterprise.context.spi.Context); } javax/enterprise/inject/spi/AfterDeploymentValidation.class package javax.enterprise.inject.spi; public abstract interface AfterDeploymentValidation { public abstract void addDeploymentProblem(Throwable); } javax/enterprise/inject/spi/Annotated.class package javax.enterprise.inject.spi; public abstract interface Annotated { public abstract reflect.Type getBaseType(); public abstract java.util.Set getTypeClosure(); public abstract annotation.Annotation getAnnotation(Class); public abstract java.util.Set getAnnotations(); public abstract boolean isAnnotationPresent(Class); } javax/enterprise/inject/spi/AnnotatedCallable.class package javax.enterprise.inject.spi; public abstract interface AnnotatedCallable extends AnnotatedMember { public abstract java.util.List getParameters(); } javax/enterprise/inject/spi/AnnotatedConstructor.class package javax.enterprise.inject.spi; public abstract interface AnnotatedConstructor extends AnnotatedCallable { public abstract reflect.Constructor getJavaMember(); } javax/enterprise/inject/spi/AnnotatedField.class package javax.enterprise.inject.spi; public abstract interface AnnotatedField extends AnnotatedMember { public abstract reflect.Field getJavaMember(); } javax/enterprise/inject/spi/AnnotatedMember.class package javax.enterprise.inject.spi; public abstract interface AnnotatedMember extends Annotated { public abstract reflect.Member getJavaMember(); public abstract boolean isStatic(); public abstract AnnotatedType getDeclaringType(); } javax/enterprise/inject/spi/AnnotatedMethod.class package javax.enterprise.inject.spi; public abstract interface AnnotatedMethod extends AnnotatedCallable { public abstract reflect.Method getJavaMember(); } javax/enterprise/inject/spi/AnnotatedParameter.class package javax.enterprise.inject.spi; public abstract interface AnnotatedParameter extends Annotated { public abstract int getPosition(); public abstract AnnotatedCallable getDeclaringCallable(); } javax/enterprise/inject/spi/AnnotatedType.class package javax.enterprise.inject.spi; public abstract interface AnnotatedType extends Annotated { public abstract Class getJavaClass(); public abstract java.util.Set getConstructors(); public abstract java.util.Set getMethods(); public abstract java.util.Set getFields(); } javax/enterprise/inject/spi/Bean.class package javax.enterprise.inject.spi; public abstract interface Bean extends javax.enterprise.context.spi.Contextual, BeanAttributes { public abstract Class getBeanClass(); public abstract java.util.Set getInjectionPoints(); } javax/enterprise/inject/spi/BeanAttributes.class package javax.enterprise.inject.spi; public abstract interface BeanAttributes { public abstract java.util.Set getTypes(); public abstract java.util.Set getQualifiers(); public abstract Class getScope(); public abstract String getName(); public abstract java.util.Set getStereotypes(); public abstract boolean isAlternative(); public abstract boolean isNullable(); } javax/enterprise/inject/spi/BeanManager.class package javax.enterprise.inject.spi; public abstract interface BeanManager { public abstract Object getReference(Bean, reflect.Type, javax.enterprise.context.spi.CreationalContext); public abstract Object getInjectableReference(InjectionPoint, javax.enterprise.context.spi.CreationalContext); public abstract javax.enterprise.context.spi.CreationalContext createCreationalContext(javax.enterprise.context.spi.Contextual); public abstract transient java.util.Set getBeans(reflect.Type, annotation.Annotation[]); public abstract java.util.Set getBeans(String); public abstract Bean getPassivationCapableBean(String); public abstract Bean resolve(java.util.Set); public abstract void validate(InjectionPoint); public abstract transient void fireEvent(Object, annotation.Annotation[]); public abstract transient java.util.Set resolveObserverMethods(Object, annotation.Annotation[]); public abstract transient java.util.List resolveDecorators(java.util.Set, annotation.Annotation[]); public abstract transient java.util.List resolveInterceptors(InterceptionType, annotation.Annotation[]); public abstract boolean isScope(Class); public abstract boolean isNormalScope(Class); public abstract boolean isPassivatingScope(Class); public abstract boolean isQualifier(Class); public abstract boolean isInterceptorBinding(Class); public abstract boolean isStereotype(Class); public abstract java.util.Set getInterceptorBindingDefinition(Class); public abstract java.util.Set getStereotypeDefinition(Class); public abstract boolean areQualifiersEquivalent(annotation.Annotation, annotation.Annotation); public abstract boolean areInterceptorBindingsEquivalent(annotation.Annotation, annotation.Annotation); public abstract int getQualifierHashCode(annotation.Annotation); public abstract int getInterceptorBindingHashCode(annotation.Annotation); public abstract javax.enterprise.context.spi.Context getContext(Class); public abstract javax.el.ELResolver getELResolver(); public abstract javax.el.ExpressionFactory wrapExpressionFactory(javax.el.ExpressionFactory); public abstract AnnotatedType createAnnotatedType(Class); public abstract AnnotatedType getAnnotatedType(Class, String); public abstract Iterable getAnnotatedTypes(Class); public abstract InjectionTarget createInjectionTarget(AnnotatedType); public abstract Producer createProducer(AnnotatedField, Bean); public abstract Producer createProducer(AnnotatedMethod, Bean); public abstract BeanAttributes createBeanAttributes(AnnotatedType); public abstract BeanAttributes createBeanAttributes(AnnotatedMember); public abstract Bean createBean(BeanAttributes, Class, InjectionTarget); public abstract Bean createBean(BeanAttributes, Class, Producer); public abstract InjectionPoint createInjectionPoint(AnnotatedField); public abstract InjectionPoint createInjectionPoint(AnnotatedParameter); public abstract Extension getExtension(Class); } javax/enterprise/inject/spi/BeforeBeanDiscovery.class package javax.enterprise.inject.spi; public abstract interface BeforeBeanDiscovery { public abstract void addQualifier(Class); public abstract void addScope(Class, boolean, boolean); public abstract transient void addStereotype(Class, annotation.Annotation[]); public abstract transient void addInterceptorBinding(Class, annotation.Annotation[]); public abstract void addAnnotatedType(AnnotatedType); } javax/enterprise/inject/spi/BeforeShutdown.class package javax.enterprise.inject.spi; public abstract interface BeforeShutdown { } javax/enterprise/inject/spi/CDI.class package javax.enterprise.inject.spi; public abstract synchronized class CDI implements javax.enterprise.inject.Instance { protected static volatile java.util.Set discoveredProviders; protected static volatile CDIProvider configuredProvider; private static final Object lock; private static final java.util.regex.Pattern nonCommentPattern; public void CDI(); public static CDI current(); public static void setCDIProvider(CDIProvider); private static void findAllProviders(); private static java.util.Set providerNamesFromReader(java.io.BufferedReader) throws java.io.IOException; public abstract BeanManager getBeanManager(); static void <clinit>(); } javax/enterprise/inject/spi/CDIProvider.class package javax.enterprise.inject.spi; public abstract interface CDIProvider { public abstract CDI getCDI(); } javax/enterprise/inject/spi/Decorator.class package javax.enterprise.inject.spi; public abstract interface Decorator extends Bean { public abstract reflect.Type getDelegateType(); public abstract java.util.Set getDelegateQualifiers(); public abstract java.util.Set getDecoratedTypes(); } javax/enterprise/inject/spi/DefinitionException.class package javax.enterprise.inject.spi; public synchronized class DefinitionException extends RuntimeException { public void DefinitionException(String, Throwable); public void DefinitionException(String); public void DefinitionException(Throwable); } javax/enterprise/inject/spi/DeploymentException.class package javax.enterprise.inject.spi; public synchronized class DeploymentException extends RuntimeException { public void DeploymentException(String, Throwable); public void DeploymentException(String); public void DeploymentException(Throwable); } javax/enterprise/inject/spi/Extension.class package javax.enterprise.inject.spi; public abstract interface Extension { } javax/enterprise/inject/spi/IdentifiedAnnotatedType.class package javax.enterprise.inject.spi; public abstract interface IdentifiedAnnotatedType extends AnnotatedType { public abstract String getID(); } javax/enterprise/inject/spi/InjectionPoint.class package javax.enterprise.inject.spi; public abstract interface InjectionPoint { public abstract reflect.Type getType(); public abstract java.util.Set getQualifiers(); public abstract Bean getBean(); public abstract reflect.Member getMember(); public abstract Annotated getAnnotated(); public abstract boolean isDelegate(); public abstract boolean isTransient(); } javax/enterprise/inject/spi/InjectionTarget.class package javax.enterprise.inject.spi; public abstract interface InjectionTarget extends Producer { public abstract void inject(Object, javax.enterprise.context.spi.CreationalContext); public abstract void postConstruct(Object); public abstract void preDestroy(Object); } javax/enterprise/inject/spi/InterceptionType.class package javax.enterprise.inject.spi; public final synchronized enum InterceptionType { public static final InterceptionType AROUND_INVOKE; public static final InterceptionType AROUND_TIMEOUT; public static final InterceptionType POST_CONSTRUCT; public static final InterceptionType PRE_DESTROY; public static final InterceptionType PRE_PASSIVATE; public static final InterceptionType POST_ACTIVATE; public static InterceptionType[] values(); public static InterceptionType valueOf(String); private void InterceptionType(String, int); static void <clinit>(); } javax/enterprise/inject/spi/Interceptor.class package javax.enterprise.inject.spi; public abstract interface Interceptor extends Bean { public abstract java.util.Set getInterceptorBindings(); public abstract boolean intercepts(InterceptionType); public abstract Object intercept(InterceptionType, Object, javax.interceptor.InvocationContext) throws Exception; } javax/enterprise/inject/spi/ObserverMethod.class package javax.enterprise.inject.spi; public abstract interface ObserverMethod { public abstract Class getBeanClass(); public abstract reflect.Type getObservedType(); public abstract java.util.Set getObservedQualifiers(); public abstract javax.enterprise.event.Reception getReception(); public abstract javax.enterprise.event.TransactionPhase getTransactionPhase(); public abstract void notify(Object); public abstract void notify(Object, java.util.Set); } javax/enterprise/inject/spi/PassivationCapable.class package javax.enterprise.inject.spi; public abstract interface PassivationCapable { public abstract String getId(); } javax/enterprise/inject/spi/ProcessAnnotatedType.class package javax.enterprise.inject.spi; public abstract interface ProcessAnnotatedType { public abstract AnnotatedType getAnnotatedType(); public abstract void setAnnotatedType(AnnotatedType); public abstract void veto(); } javax/enterprise/inject/spi/ProcessBean.class package javax.enterprise.inject.spi; public abstract interface ProcessBean { public abstract Annotated getAnnotated(); public abstract Bean getBean(); public abstract void addDefinitionError(Throwable); } javax/enterprise/inject/spi/ProcessBeanAttributes.class package javax.enterprise.inject.spi; public abstract interface ProcessBeanAttributes { public abstract Annotated getAnnotated(); public abstract BeanAttributes getBeanAttributes(); public abstract void setBeanAttributes(BeanAttributes); public abstract void addDefinitionError(Throwable); public abstract void veto(); } javax/enterprise/inject/spi/ProcessInjectionPoint.class package javax.enterprise.inject.spi; public abstract interface ProcessInjectionPoint { public abstract InjectionPoint getInjectionPoint(); public abstract void setInjectionPoint(InjectionPoint); public abstract void addDefinitionError(Throwable); } javax/enterprise/inject/spi/ProcessInjectionTarget.class package javax.enterprise.inject.spi; public abstract interface ProcessInjectionTarget { public abstract AnnotatedType getAnnotatedType(); public abstract InjectionTarget getInjectionTarget(); public abstract void setInjectionTarget(InjectionTarget); public abstract void addDefinitionError(Throwable); } javax/enterprise/inject/spi/ProcessManagedBean.class package javax.enterprise.inject.spi; public abstract interface ProcessManagedBean extends ProcessBean { public abstract AnnotatedType getAnnotatedBeanClass(); } javax/enterprise/inject/spi/ProcessModule.class package javax.enterprise.inject.spi; public abstract interface ProcessModule { public abstract java.util.Set getAlternatives(); public abstract java.util.List getInterceptors(); public abstract java.util.List getDecorators(); public abstract java.util.Iterator getAnnotatedTypes(); public abstract java.io.InputStream getBeansXml(); } javax/enterprise/inject/spi/ProcessObserverMethod.class package javax.enterprise.inject.spi; public abstract interface ProcessObserverMethod { public abstract AnnotatedMethod getAnnotatedMethod(); public abstract ObserverMethod getObserverMethod(); public abstract void addDefinitionError(Throwable); } javax/enterprise/inject/spi/ProcessProducer.class package javax.enterprise.inject.spi; public abstract interface ProcessProducer { public abstract AnnotatedMember getAnnotatedMember(); public abstract Producer getProducer(); public abstract void setProducer(Producer); public abstract void addDefinitionError(Throwable); } javax/enterprise/inject/spi/ProcessProducerField.class package javax.enterprise.inject.spi; public abstract interface ProcessProducerField extends ProcessBean { public abstract AnnotatedField getAnnotatedProducerField(); public abstract AnnotatedParameter getAnnotatedDisposedParameter(); } javax/enterprise/inject/spi/ProcessProducerMethod.class package javax.enterprise.inject.spi; public abstract interface ProcessProducerMethod extends ProcessBean { public abstract AnnotatedMethod getAnnotatedProducerMethod(); public abstract AnnotatedParameter getAnnotatedDisposedParameter(); } javax/enterprise/inject/spi/ProcessSessionBean.class package javax.enterprise.inject.spi; public abstract interface ProcessSessionBean extends ProcessManagedBean { public abstract String getEjbName(); public abstract SessionBeanType getSessionBeanType(); } javax/enterprise/inject/spi/ProcessSyntheticAnnotatedType.class package javax.enterprise.inject.spi; public abstract interface ProcessSyntheticAnnotatedType extends ProcessAnnotatedType { public abstract Extension getSource(); } javax/enterprise/inject/spi/Producer.class package javax.enterprise.inject.spi; public abstract interface Producer { public abstract Object produce(javax.enterprise.context.spi.CreationalContext); public abstract void dispose(Object); public abstract java.util.Set getInjectionPoints(); } javax/enterprise/inject/spi/SessionBeanType.class package javax.enterprise.inject.spi; public final synchronized enum SessionBeanType { public static final SessionBeanType STATELESS; public static final SessionBeanType STATEFUL; public static final SessionBeanType SINGLETON; public static SessionBeanType[] values(); public static SessionBeanType valueOf(String); private void SessionBeanType(String, int); static void <clinit>(); } javax/enterprise/inject/spi/WithAnnotations.class package javax.enterprise.inject.spi; public abstract interface WithAnnotations extends annotation.Annotation { public abstract Class[] value(); } javax/enterprise/inject/Stereotype.class package javax.enterprise.inject; public abstract interface Stereotype extends annotation.Annotation { } javax/enterprise/inject/Typed.class package javax.enterprise.inject; public abstract interface Typed extends annotation.Annotation { public abstract Class[] value(); } javax/enterprise/inject/UnproxyableResolutionException.class package javax.enterprise.inject; public synchronized class UnproxyableResolutionException extends ResolutionException { private static final long serialVersionUID = 1667539354548135465; public void UnproxyableResolutionException(); public void UnproxyableResolutionException(String, Throwable); public void UnproxyableResolutionException(String); public void UnproxyableResolutionException(Throwable); } javax/enterprise/inject/UnsatisfiedResolutionException.class package javax.enterprise.inject; public synchronized class UnsatisfiedResolutionException extends ResolutionException { private static final long serialVersionUID = 5350603312442756709; public void UnsatisfiedResolutionException(); public void UnsatisfiedResolutionException(String, Throwable); public void UnsatisfiedResolutionException(String); public void UnsatisfiedResolutionException(Throwable); } javax/enterprise/inject/Vetoed.class package javax.enterprise.inject; public abstract interface Vetoed extends annotation.Annotation { } javax/enterprise/util/AnnotationLiteral.class package javax.enterprise.util; public abstract synchronized class AnnotationLiteral implements annotation.Annotation, java.io.Serializable { private static final long serialVersionUID = 1; private transient Class annotationType; private transient reflect.Method[] members; private transient Integer cachedHashCode; protected void AnnotationLiteral(); private reflect.Method[] getMembers(); private static Class getAnnotationLiteralSubclass(Class); private static Class getTypeParameter(Class); public Class annotationType(); public String toString(); private void appendInBraces(StringBuilder, String); public boolean equals(Object); public int hashCode(); private static Object getMemberValue(reflect.Method, annotation.Annotation); private static Object invoke(reflect.Method, Object); } javax/enterprise/util/Nonbinding.class package javax.enterprise.util; public abstract interface Nonbinding extends annotation.Annotation { } javax/enterprise/util/TypeLiteral.class package javax.enterprise.util; public abstract synchronized class TypeLiteral implements java.io.Serializable { private static final long serialVersionUID = 1; private transient reflect.Type actualType; protected void TypeLiteral(); public final reflect.Type getType(); public final Class getRawType(); private static Class getTypeLiteralSubclass(Class); private static reflect.Type getTypeParameter(Class); public boolean equals(Object); public int hashCode(); public String toString(); } META-INF/DEPENDENCIES.txt // ------------------------------------------------------------------ // Transitive dependencies of this project determined from the // maven pom organized by organization. // ------------------------------------------------------------------ CDI APIs From: 'an unknown organization' - JSR-250 Common Annotations for the JavaTM Platform (http://jcp.org/aboutJava/communityprocess/final/jsr250/index.html) javax.annotation:jsr250-api:jar:1.0 License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0 (https://glassfish.dev.java.net/public/CDDLv1.0.html) - Expression Language API (2.1 Maintenance Release) javax.el:el-api:jar:2.2 - javax.inject (http://code.google.com/p/atinject/) javax.inject:javax.inject:jar:1 License: The Apache Software License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.txt) From: 'JBoss, a division of Red Hat, Inc.' (http://www.jboss.org) - EJB 3.1 API (http://jboss-ejb-api_3.1_spec/) org.jboss.spec.javax.ejb:jboss-ejb-api_3.1_spec:jar:1.0.0.CR2 License: lgpl (http://repository.jboss.org/licenses/lgpl-2.1.txt) - Interceptors 1.1 API (http://jboss-interceptors-api_1.1_spec/) org.jboss.spec.javax.interceptor:jboss-interceptors-api_1.1_spec:jar:1.0.0.Beta1 License: lgpl (http://repository.jboss.org/licenses/lgpl-2.1.txt) META-INF/LICENSE.txt Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. META-INF/maven/javax.enterprise/cdi-api/pom.xml 4.0.0 org.jboss.weld weld-parent 19 javax.enterprise cdi-api jar 1.1-PRD CDI APIs APIs for CDI (Contexts and Dependency Injection for Java EE) http://www.seamframework.org/Weld Apache License, Version 2.0 repo http://www.apache.org/licenses/LICENSE-2.0.html Hudson http://hudson.jboss.org JIRA http://jira.jboss.org/browse/CDI JBoss by Red Hat, Inc. http://jboss.org 2008 Pete Muir pmuir Red Hat Inc. Specfication Lead pmuir@redhat.com Shane Bryzak Red Hat Inc. David Allen Nicklas Karlsson George Gastaldi 1 1.0.0.CR2 1.0 2.2 1.0.0.Beta1 org.testng testng 5.10 jdk15 javax.annotation jsr250-api ${jsr250.api.version} javax.inject javax.inject ${atinject.api.version} javax.el el-api ${uel.api.version} org.jboss.spec.javax.ejb jboss-ejb-api_3.1_spec ${ejb.api.version} jboss-transaction-api_1.1_spec org.jboss.spec.javax.transaction jaxrpc-api javax.xml org.jboss.spec.javax.interceptor jboss-interceptors-api_1.1_spec ${interceptor.api.version} javax.el el-api org.jboss.spec.javax.ejb jboss-ejb-api_3.1_spec true org.jboss.spec.javax.interceptor jboss-interceptors-api_1.1_spec javax.annotation jsr250-api javax.inject javax.inject org.testng testng jdk15 test scm:git:git@github.com:jboss/cdi.git scm:git:git@github.com:jboss/cdi.git scm:git:git@github.com:jboss/cdi.git jboss-public-repository jboss-public-repository !false jboss-public-repository-group JBoss Public Maven Repository Group http://repository.jboss.org/nexus/content/groups/public true never false never jboss-public-repository-group JBoss Public Maven Repository Group http://repository.jboss.org/nexus/content/groups/public true never false never META-INF/maven/javax.enterprise/cdi-api/pom.properties #Generated by Maven #Fri Oct 26 18:18:46 BST 2012 version=1.1-PRD groupId=javax.enterprise artifactId=cdi-api"
    } ],
    "message_attachments_cnt" : 2
}