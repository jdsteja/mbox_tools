{
    "author" : "Stuart Douglas <stuart.w.douglas@gmail.com>",
    "to" : [ "Marko Lukša <marko.luksa@gmail.com>" ],
    "subject_original" : "Re: [weld-dev] Bridge methods & proxies & interceptors",
    "subject" : "Bridge methods & proxies & interceptors",
    "date" : "2012-09-07T15:27:40.000Z",
    "message_id_original" : "<504A126C.4060204@gmail.com>",
    "message_id" : "<504A126C.4060204@gmail.com>",
    "references" : [ "<5049BC14.9030108@gmail.com>" ],
    "in_reply_to" : "<5049BC14.9030108@gmail.com>",
    "message_snippet" : "IMHO the correct way to deal with this is to simply make bridge methods delegate to super(), which will then result in the actual intercepted method being called. To be honest I thought we already did this, as we have had multiple related bugs in the",
    "first_text_message" : "IMHO the correct way to deal with this is to simply make bridge methods \ndelegate to super(), which will then result in the actual intercepted \nmethod being called.\n\nTo be honest I thought we already did this, as we have had multiple \nrelated bugs in the past. Do you have a test case that I can look at?\n\nStuart\n\n&gt; Marko Lukša &lt;mailto:marko.luksa@gmail.com&gt;\n&gt; 7 September 2012 7:19 PM\n&gt; Hey all.\n&gt;\n&gt; I've been working on https://issues.jboss.org/browse/WELD-1162 and \n&gt; need your opinion.\n&gt;\n&gt; Say we have:\n&gt;\n&gt; public interface Foo&lt;T&gt; {\n&gt;    void doSomething(T t);\n&gt; }\n&gt; public interface StringFoo extends Foo&lt;String&gt; {}\n&gt; public class StringFooImpl implements StringFoo {}\n&gt;\n&gt; and\n&gt;\n&gt; @Inject StringFoo stringFoo;\n&gt;\n&gt; The proxy created by Weld is a subclass of StringFooImpl and therefore \n&gt; has two declared methods:\n&gt;\n&gt; void doSomething(Object o) { doSomething((String) o); }\n&gt; void doSomething(String) {...}\n&gt;\n&gt; However, when StringFooImpl is a session bean, with StringFoo as its \n&gt; local interface, the proxy is a subclass of Object and therefore the \n&gt; proxy only has the following declared method:\n&gt;\n&gt; void doSomething(Object o);\n&gt;\n&gt; In both cases, when a client invokes stringFoo.doSomething(\"foo\"), the \n&gt; method doSomething(Object) is invoked. But there's a difference in \n&gt; what happens next:\n&gt;\n&gt;   * In the non-ejb version, the bridge method then immediately invokes\n&gt;     doSomething(String) and only then is the proxy's method handler\n&gt;     invoked. The handler is therefore dealing with the method\n&gt;     doSomething(*String*)\n&gt;   * in the EJB version, doSomething(Object) is not a bridge method,\n&gt;     and so the method handler is invoked directly and it (the handler)\n&gt;     is operating on doSomething(*Object*).\n&gt;\n&gt; In the second case, this ultimately means that Weld will check whether \n&gt; doSomething(Object) is intercepted. It isn't, since \n&gt; Beans.getInterceptableMethods() is ignoring bridge methods. The \n&gt; interceptor will not be invoked. On the other hand, in the first case, \n&gt; the interceptor _will_ be invoked, since Weld will be checking whether \n&gt; doSomething(String) is intercepted.\n&gt;\n&gt; My initial solution was to make Beans.getInterceptableMethods() also \n&gt; return bridge methods, but now I'm thinking the actual problem is in \n&gt; the proxy itself. IMO, when creating a proxy based on an interface, we \n&gt; should also generate bridge methods on the proxy (this should be \n&gt; either done by Weld or by Javassist directly). These bridge methods \n&gt; should be perfectly normal bridge methods and should not invoke the \n&gt; method handler directly. They should simply invoke the non-bridge \n&gt; method and the non-bridge method should then invoke the method handler.\n&gt;\n&gt; The java compiler can't add bridge methods directly to interfaces \n&gt; which require them, so it adds them to all the classes implementing \n&gt; the interface (StringFooImpl in our case). Since we are creating \n&gt; StringFoo$Proxy, which is also a class implementing an interface which \n&gt; requires bridge methods, we should add the bridge methods\n&gt; to it - exactly as the java compiler would.\n&gt;\n&gt; This would solve the interceptor problem and possibly other similar \n&gt; problems as well.\n&gt;\n&gt; What do you think?\n&gt;\n&gt; Marko\n&gt;\n&gt;\n&gt; _______________________________________________\n&gt; weld-dev mailing list\n&gt; weld-dev@lists.jboss.org\n&gt; https://lists.jboss.org/mailman/listinfo/weld-dev\n",
    "first_text_message_without_quotes" : "IMHO the correct way to deal with this is to simply make bridge methods delegate to super(), which will then result in the actual intercepted method being called. To be honest I thought we already did this, as we have had multiple related bugs in the past. Do you have a test case that I can look at? Stuart",
    "text_messages" : [ ],
    "text_messages_cnt" : 0,
    "html_messages" : [ ],
    "html_messages_cnt" : 0
}